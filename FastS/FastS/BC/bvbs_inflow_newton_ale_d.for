C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) - 28 May 2018 09:28
C
C  Differentiation of bvbs_inflow_newton in forward (tangent) mode:
C   variations   of useful results: rop
C   with respect to varying inputs: rop d0x d0y d0z ha c4 c5 c6
C                nue tijk param_real pa ventijk
C   RW status of diff variables: rop:in-out d0x:in d0y:in d0z:in
C                ha:in c4:in c5:in c6:in nue:in tijk:in param_real:in
C                pa:in ventijk:in
C
C
C
C
C
C
C
C
C
C
C
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 aoÃ»t 2013) $
C     $Revision: 35 $
C     $Author: IvanMary $
C***********************************************************************
      SUBROUTINE BVBS_INFLOW_NEWTON_D(idir, lrhs, neq_mtr, param_int, 
     +                                ind_loop, param_real, param_reald
     +                                , c4, c4d, c5, c5d, c6, c6d, 
     +                                ventijk, ventijkd, tijk, tijkd, 
     +                                rop, ropd, d0x, d0xd, d0y, d0yd, 
     +                                d0z, d0zd, pa, pad, ha, had, nue, 
     +                                nued, size_data, inc_bc, size_work
     +)
      IMPLICIT NONE
C
CSeule la valeur de k_vent et ck_vent a un sens dans cet appel
C
C
C
C
Cj
C
C
c      INCLUDE 'DIFFSIZES.inc'
C  Hint: size_work should be the value of size_work
C  Hint: size_work should be the value of size_work
C  Hint: size_work should be the value of size_work
C  Hint: size_work should be the value of size_work
C  Hint: size_work should be the value of size_work
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER*4 idir, lrhs, neq_mtr, ind_loop(6), param_int(0:*)
      INTEGER*4 size_data, inc_bc, size_work
      REAL*8 rop(param_int(41), param_int(36))
      REAL*8 ropd(param_int(41), param_int(36))
      REAL*8 ventijk(param_int(44), param_int(40))
      REAL*8 ventijkd(param_int(44), param_int(40))
      REAL*8 tijk(param_int(43), neq_mtr)
      REAL*8 tijkd(param_int(43), neq_mtr)
C
C...  Contient les donnees CGNS pour l injection subsonique:
      REAL*8 d0x(size_data), d0y(size_data), d0z(size_data), pa(
     +       size_data), ha(size_data), nue(size_data)
      REAL*8 d0xd(size_data), d0yd(size_data), d0zd(size_data), pad(
     +       size_data), had(size_data), nued(size_data)
C
      REAL*8 c4, c5, c6, param_real(0:*)
      REAL*8 c4d, c5d, c6d, param_reald(0:*)
C
C Var local
      INTEGER*4 l, lij, lr, lp, i, j, k, l1, l2, ic, jc, kc, kc_vent, 
     +          ldp, lmtr, l0, incj, inck, nitnwt, nd, li, lit
      REAL*8 ro, u, v, w, t, nut, c6inv, c0, c1, c2, c3, roe, rue, rve, 
     +       rwe, ete, ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale, tcx, tcy
     +       , tcz, qref1, qref2, qref3, qref4, qref5, r, p, c, ci, 
     +       snorm, gam, gam1, gam1_1, gam2, rgp, sni, tn, qn, qen, 
     +       eigv1, eigv2, eigv3, eigv4, eigv5, qvar1, qvar2, qvar3, 
     +       qvar4, qvar5, svar1, svar2, svar3, svar4, svar5, rvar1, 
     +       rvar2, rvar3, rvar4, rvar5, roext, ruext, rvext, rwext, 
     +       etext, roint, ruint, rvint, rwint, etint, s_1, roi, rui, 
     +       rvi, rwi
      REAL*8 eti, tnx, tny, tnz, roinv, sn, roe_inv
      REAL*8 c0d, c1d, c2d, c3d, tcxd, tcyd, tczd, gamd, gam1d, gam2d, 
     +       rgpd, qend, s_1d, roid, tnxd, tnyd, tnzd, snd
C
      REAL*8 ui, vi, wi, ti, ro0, u0, v0, w0, t0
      REAL*8 uid, vid, wid, tid, ro0d, u0d, v0d, w0d, t0d
      REAL*8 cg, mg, vg, pg, roa, roinf
      REAL*8 vgd, pgd
      REAL*8 b, f, df, tg, rog, rpg, p0, vn0, vng, pi, vni, wni, wn0, 
     +       residug, dwng
      REAL*8 bd, fd, dfd, tgd, rogd, p0d, vngd, pid, vnid, wnid, wn0d, 
     +       dwngd
      REAL*8 newtonmax, tolnewton
      REAL*8 roc0l, ril, d0nl, d0n2l, vngl, residul
      REAL*8 ventx, venty, ventz
      REAL*8 ventxd, ventyd, ventzd
C
C...  Tableaux de travail locaux
      REAL*8 roc0(size_work), usd0n(size_work), usd0n2(size_work), ri(
     +       size_work), wng(size_work)
      LOGICAL nan
      INTEGER*4 indbci, ithread
C    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER*4 inddm, i_1, j_1, k_1
C    adresse interface pour tableau metric
      INTEGER*4 indmtr, i_3, j_3, k_3
C    adresse interface pour tableau vitesse entrainement
      INTEGER*4 indven, i_4, j_4, k_4
      EXTERNAL SHAPE_TAB_MTR
      INTRINSIC MOD
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      REAL*8 abs0
      REAL*8 abs1
      REAL*8 abs2
      REAL*8 abs3
      REAL*8 abs4
      REAL*8 abs5
      REAL*8 arg1
      REAL*8 arg1d
      REAL*8 pwr1
      REAL*8 pwr1d
      INTEGER ii1
      REAL*8 usd0n2d(size_work)
      REAL*8 y12
      REAL*8 y11
      REAL*8 y10
      REAL*8 wngd(size_work)
      REAL*8 usd0nd(size_work)
      REAL*8 roc0d(size_work)
      REAL*8 rid(size_work)
      REAL*8 y9
      REAL*8 y8
      REAL*8 y7
      REAL*8 y6
      REAL*8 y5
      REAL*8 y4
      REAL*8 y3
      REAL*8 y2
      REAL*8 y1
C
C......determine la forme des tableuz metrique en fonction de la nature du domaine
      CALL SHAPE_TAB_MTR(neq_mtr, param_int, idir, ic, jc, kc, kc_vent, 
     +                   ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale)
C
C
      snorm = -1.
C!! premiere rangee = CL
C!! rangee suivante pour que : Phi_L + Phi_R = 2 * state
      IF (MOD(idir, 2) .EQ. 0) snorm = 1.
      gamd = param_reald(1)
      gam = param_real(1)
      gam1d = gamd
      gam1 = gam - 1.
      gam1_1 = 1./gam1
      gam2d = (gamd*gam1-gam*gam1d)/gam1**2
      gam2 = gam/gam1
      rgpd = param_reald(2)*gam1 + param_real(2)*gam1d
      rgp = param_real(2)*gam1
      newtonmax = param_int(65)
      tolnewton = param_real(37)
      c0d = -(c6d/c6**2)
      c0 = 1./c6
      c1d = -((c4d+c5d)*c0+(c4+c5)*c0d)
      c1 = -((c4+c5)*c0)
      c2d = -(c6d*c0+c6*c0d)
      c2 = -(c6*c0)
Cwrite(*,'(a,7i4)')'BC', ind_loop, idir
      c3d = (-c5d-c4d)*c0 + (2.-c5-c4)*c0d
      c3 = (2.-c5-c4)*c0
Cidir
C
      IF (idir .EQ. 1) THEN
Cparam_int(36)
        IF (param_int(36) .EQ. 5) THEN
CConstruction premier vecteur pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              lit = 1
CInit Newton
              li = 1 + (j-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(lit) = wn0d
              wng(lit) = wn0
              residug = 1.e+20
              nitnwt = 0
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y1 = dwng/wng(lit)
                ELSE
                  y1 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y1) THEN
                  residug = y1
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
CMise a jour next rank
              ropd(l, 5) = tgd
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs0 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs0 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs0 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
C
C
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              lit = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-1) + (k-1)*inc_bc
C
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
C write(*,*) ventx, venty, ventz, j,k
Cresolution Newton             
              wngd(lit) = wn0d
              wng(lit) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y2 = dwng/wng(lit)
                ELSE
                  y2 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y2) THEN
                  residug = y2
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
CMise a jour next rank
              ropd(l, 6) = nued(li)
C
C
C
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 2) THEN
C
C
C
C
C
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              lit = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-1) + (k-1)*inc_bc
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(lit) = wn0d
              wng(lit) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y3 = dwng/wng(lit)
                ELSE
                  y3 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y3) THEN
                  residug = y3
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
CMise a jour next rank
              ropd(l, 5) = tgd
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs1 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs1 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs1 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
C
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              lit = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-1) + (k-1)*inc_bc
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(lit) = wn0d
              wng(lit) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y4 = dwng/wng(lit)
                ELSE
                  y4 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y4) THEN
                  residug = y4
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
CMise a jour next rank
              ropd(l, 6) = nued(li)
C
C
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 3) THEN
C
C
C
C
        incj = param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (4)+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(
     +            5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                lit = lit + 1
                li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y5 = dwng/wng(lit)
                ELSE
                  y5 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y5) THEN
                  residug = y5
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
Ci
CEnd Newton
CMise a jour first rank
            lit = 0
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
            ENDDO
Ci
CMise a jour next rank
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs2 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs2 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs2 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
Ci
Cj
C
Ck
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (4)+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(
     +            5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                lit = lit + 1
                li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y6 = dwng/wng(lit)
                ELSE
                  y6 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y6) THEN
                  residug = y6
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
Ci
CEnd Newton
CMise a jour first rank
            lit = 0
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
              ropd(l, 6) = nued(li)
            ENDDO
C
C
Ci
CMise a jour next rank
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 4) THEN
C
Ci
Cj
C
Ck
C
C
C
        incj = -param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (3)+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+
     +            4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(3)+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                lit = lit + 1
                li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y7 = dwng/wng(lit)
                ELSE
                  y7 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y7) THEN
                  residug = y7
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
Ci
CEnd Newton 
CMise a jour first rank
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
            ENDDO
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs3 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs3 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs3 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
Ci
Cj
C
Ck
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (3)+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+
     +            4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(3)+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                lit = lit + 1
                li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y8 = dwng/wng(lit)
                ELSE
                  y8 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y8) THEN
                  residug = y8
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
Ci
CEnd Newton 
CMise a jour first rank
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              lit = lit + 1
              li = 1 + (i-1) + (k-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
              ropd(l, 6) = nued(li)
            ENDDO
C
C
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 5) THEN
C
Ci
Cj
C
Ck
C
C
C
        inck = param_int(0)*param_int(0+1)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                lit = lit + 1
                li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y9 = dwng/wng(lit)
                ELSE
                  y9 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y9) THEN
                  residug = y9
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
CEnd Newton 
CMise a jour first rank
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
            ENDDO
CMise a jour next rank
C
            DO k=ind_loop(5),ind_loop(6)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs4 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs4 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs4 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
C
Cj
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                lit = lit + 1
                li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y10 = dwng/wng(lit)
                ELSE
                  y10 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y10) THEN
                  residug = y10
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
CEnd Newton 
CMise a jour first rank
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
              ropd(l, 6) = nued(li)
            ENDDO
C
C
CMise a jour next rank
C
            DO k=ind_loop(5),ind_loop(6)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE
C
C
Cj
C
C
C
C
        inck = -(param_int(0)*param_int(0+1))
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                lit = lit + 1
                li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y11 = dwng/wng(lit)
                ELSE
                  y11 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y11) THEN
                  residug = y11
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
CEnd Newton
CMise a jour first rank
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
            ENDDO
CMise a jour next rank
C
            DO k=ind_loop(5)+1,ind_loop(6)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs5 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs5 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs5 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
Cj
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = (roid*rgp+roi*rgpd)*ti + roi*rgp*tid
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = (ro0d*rgp+ro0*rgpd)*t0 + ro0*rgp*t0d
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = uid*tnx + ui*tnxd + vid*tny + vi*tnyd + wid*tnz + 
     +          wi*tnzd
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = (ro0d*gam+ro0*gamd)*p0 + ro0*gam*p0d
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(lit) = 0.D0
              ELSE
                roc0d(lit) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(lit) = SQRT(arg1)
              usd0nd(lit) = -((d0xd(li)*tnx+d0x(li)*tnxd+d0yd(li)*tny+
     +          d0y(li)*tnyd+d0zd(li)*tnz+d0z(li)*tnzd)/(d0x(li)*tnx+d0y
     +          (li)*tny+d0z(li)*tnz)**2)
              usd0n(lit) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2d(lit) = 2*usd0n(lit)*usd0nd(lit)
              usd0n2(lit) = usd0n(lit)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid - qend
              wni = vni - qen
              rid(lit) = pid + roc0d(lit)*wni + roc0(lit)*wnid
              ri(lit) = pi + roc0(lit)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = u0d*tnx + u0*tnxd + v0d*tny + v0*tnyd + w0d*tnz + 
     +          w0*tnzd - qend
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(lit) = wn0d
              wng(lit) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              lit = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                lit = lit + 1
                li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tczd = ck_mtr*snorm*tijkd(lmtr, kc)
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd
     +            *tcz + tcz*tczd
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                IF (arg1 .EQ. 0.0) THEN
                  snd = 0.D0
                ELSE
                  snd = arg1d/(2.0*SQRT(arg1))
                END IF
                sn = SQRT(arg1)
C
                s_1d = -(snd/sn**2)
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                  tnxd = 0.0
                  tnyd = 0.0
                  tnzd = 0.0
                ELSE
                  tnxd = tcxd*s_1 + tcx*s_1d
                  tnx = tcx*s_1
                  tnyd = tcyd*s_1 + tcy*s_1d
                  tny = tcy*s_1
                  tnzd = tczd*s_1 + tcz*s_1d
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventxd = ventijkd(ldp, 1)
                ventx = ventijk(ldp, 1)
                ventyd = ventijkd(ldp, 2)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventzd = ck_vent*ventijkd(ldp, kc_vent)
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*
     +            tnyd+ventzd*tnz+ventz*tnzd)
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(((2*(wng(lit)+qen)*(wngd(lit)+qend)*usd0n2(lit)+(
     +            wng(lit)+qen)**2*usd0n2d(lit))*2.*ha(li)-(wng(lit)+qen
     +            )**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
                b = 1. - (wng(lit)+qen)**2*usd0n2(lit)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0) THEN
                  pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
                ELSE IF (b .EQ. 0.0) THEN
                  IF (gam2 .EQ. 1.0) THEN
                    pwr1d = bd
                  ELSE
                    pwr1d = 0.0
                  END IF
                ELSE IF (gam2 .EQ. INT(gam2)) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pad(li)*pwr1 + pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+
     +            ha(li)*bd))/(ha(li)*b)**2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(lit)*wng(lit) + roc0(lit)*wngd(lit) - 
     +            rid(lit)
                f = pg + roc0(lit)*wng(lit) - ri(lit)
                dfd = roc0d(lit) - (rogd*usd0n2(lit)+rog*usd0n2d(lit))*(
     +            wng(lit)+qen) - rog*usd0n2(lit)*(wngd(lit)+qend)
                df = roc0(lit) - rog*(wng(lit)+qen)*usd0n2(lit)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(lit) = wngd(lit) + dwngd
                wng(lit) = wng(lit) + dwng
                IF (dwng/wng(lit) .GE. 0.) THEN
                  y12 = dwng/wng(lit)
                ELSE
                  y12 = -(dwng/wng(lit))
                END IF
                IF (residug .LT. y12) THEN
                  residug = y12
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
CEnd Newton
CMise a jour first rank
C
            lit = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              lit = lit + 1
              li = 1 + (i-1) + (j-1)*inc_bc
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcxd = ci_mtr*snorm*tijkd(lmtr, ic)
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcyd = cj_mtr*snorm*tijkd(lmtr, jc)
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tczd = ck_mtr*snorm*tijkd(lmtr, kc)
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1d = tcxd*tcx + tcx*tcxd + tcyd*tcy + tcy*tcyd + tczd*
     +          tcz + tcz*tczd
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              IF (arg1 .EQ. 0.0) THEN
                snd = 0.D0
              ELSE
                snd = arg1d/(2.0*SQRT(arg1))
              END IF
              sn = SQRT(arg1)
C
              s_1d = -(snd/sn**2)
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
                tnxd = 0.0
                tnyd = 0.0
                tnzd = 0.0
              ELSE
                tnxd = tcxd*s_1 + tcx*s_1d
                tnx = tcx*s_1
                tnyd = tcyd*s_1 + tcy*s_1d
                tny = tcy*s_1
                tnzd = tczd*s_1 + tcz*s_1d
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventxd = ventijkd(ldp, 1)
              ventx = ventijk(ldp, 1)
              ventyd = ventijkd(ldp, 2)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventzd = ck_vent*ventijkd(ldp, kc_vent)
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qend = c_ale*(ventxd*tnx+ventx*tnxd+ventyd*tny+venty*tnyd+
     +          ventzd*tnz+ventz*tnzd)
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(lit) + qend
              vng = wng(lit) + qen
C...      Absolute velocity module
              vgd = vngd*usd0n(lit) + vng*usd0nd(lit)
              vg = vng*usd0n(lit)
              bd = -(((2*vng*vngd*usd0n2(lit)+vng**2*usd0n2d(lit))*2.*ha
     +          (li)-vng**2*usd0n2(lit)*2.*had(li))/(2.*ha(li))**2)
              b = 1. - vng**2*usd0n2(lit)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0) THEN
                pwr1d = b**gam2*(LOG(b)*gam2d+gam2*bd/b)
              ELSE IF (b .EQ. 0.0) THEN
                IF (gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
              ELSE IF (gam2 .EQ. INT(gam2)) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pad(li)*pwr1 + pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = ((gam2d*pg+gam2*pgd)*ha(li)*b-gam2*pg*(had(li)*b+ha
     +          (li)*bd))/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*(rogd*rgp+rog*rgpd))/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = vgd*d0x(li) + vg*d0xd(li)
              ropd(l, 3) = vgd*d0y(li) + vg*d0yd(li)
              ropd(l, 4) = vgd*d0z(li) + vg*d0zd(li)
              ropd(l, 5) = tgd
              ropd(l, 6) = nued(li)
            ENDDO
C
C
CMise a jour next rank
C
            DO k=ind_loop(5)+1,ind_loop(6)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = ropd(l0, 1)*c3 + rop(l0, 1)*c3d + ropd(l1, 
     +            1)*c1 + rop(l1, 1)*c1d + ropd(l2, 1)*c2 + rop(l2, 1)*
     +            c2d
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = ropd(l0, 2)*c3 + rop(l0, 2)*c3d + ropd(l1
     +              , 2)*c1 + rop(l1, 2)*c1d + ropd(l2, 2)*c2 + rop(l2, 
     +              2)*c2d
                  ropd(l, 3) = ropd(l0, 3)*c3 + rop(l0, 3)*c3d + ropd(l1
     +              , 3)*c1 + rop(l1, 3)*c1d + ropd(l2, 3)*c2 + rop(l2, 
     +              3)*c2d
                  ropd(l, 4) = ropd(l0, 4)*c3 + rop(l0, 4)*c3d + ropd(l1
     +              , 4)*c1 + rop(l1, 4)*c1d + ropd(l2, 4)*c2 + rop(l2, 
     +              4)*c2d
                  ropd(l, 5) = ropd(l0, 5)*c3 + rop(l0, 5)*c3d + ropd(l1
     +              , 5)*c1 + rop(l1, 5)*c1d + ropd(l2, 5)*c2 + rop(l2, 
     +              5)*c2d
                  ropd(l, 6) = ropd(l0, 6)*c3 + rop(l0, 6)*c3d + ropd(l1
     +              , 6)*c1 + rop(l1, 6)*c1d + ropd(l2, 6)*c2 + rop(l2, 
     +              6)*c2d
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      END IF
      END

