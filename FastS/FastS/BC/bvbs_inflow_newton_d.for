C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) - 28 May 2018 09:28
C
C  Differentiation of bvbs_inflow_newton in forward (tangent) mode:
C   variations   of useful results: rop
C   with respect to varying inputs: rop
C   RW status of diff variables: rop:in-out
C
C
C
C
C
C
C
C
C
C
C
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 aoÃ»t 2013) $
C     $Revision: 35 $
C     $Author: IvanMary $
C***********************************************************************
      SUBROUTINE BVBS_INFLOW_NEWTON_D(idir, lrhs, neq_mtr, param_int, 
     +                                ind_loop, param_real, c4, c5, c6, 
     +                                ventijk, tijk, rop, ropd, d0x, d0y
     +                                , d0z, pa, ha, nue, size_data, 
     +                                inc_bc, size_work)
      IMPLICIT NONE
C
CSeule la valeur de k_vent et ck_vent a un sens dans cet appel
C
C
C
C
Cj
C
C
c      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFroc0dINbvbs_inflow_newton should be the value of size_work
C  Hint: ISIZE1OFridINbvbs_inflow_newton should be the value of size_work
C  Hint: ISIZE1OFwngdINbvbs_inflow_newton should be the value of size_work
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER*4 idir, lrhs, neq_mtr, ind_loop(6), param_int(0:*)
      INTEGER*4 size_data, inc_bc(3), size_work
      REAL*8 rop(param_int(41), param_int(36))
      REAL*8 ropd(param_int(41), param_int(36))
      REAL*8 ventijk(param_int(44), param_int(40))
      REAL*8 tijk(param_int(43), neq_mtr)
C
C...  Contient les donnees CGNS pour l injection subsonique:
      REAL*8 d0x(size_data), d0y(size_data), d0z(size_data), pa(
     +       size_data), ha(size_data), nue(size_data)
C
      REAL*8 c4, c5, c6, param_real(0:*)
C
C Var local
      INTEGER*4 l, lij, lr, lp, i, j, k, l1, l2, ic, jc, kc, kc_vent, 
     +          ldp, lmtr, l0, incj, inck, nitnwt, nd, li
      REAL*8 ro, u, v, w, t, nut, c6inv, c0, c1, c2, c3, roe, rue, rve, 
     +       rwe, ete, ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale, tcx, tcy
     +       , tcz, qref1, qref2, qref3, qref4, qref5, r, p, c, ci, 
     +       snorm, gam, gam1, gam1_1, gam2, rgp, sni, tn, qn, qen, 
     +       eigv1, eigv2, eigv3, eigv4, eigv5, qvar1, qvar2, qvar3, 
     +       qvar4, qvar5, svar1, svar2, svar3, svar4, svar5, rvar1, 
     +       rvar2, rvar3, rvar4, rvar5, roext, ruext, rvext, rwext, 
     +       etext, roint, ruint, rvint, rwint, etint, s_1, roi, rui, 
     +       rvi, rwi
      REAL*8 eti, tnx, tny, tnz, roinv, sn, roe_inv
      REAL*8 roid
C
      REAL*8 ui, vi, wi, ti, ro0, u0, v0, w0, t0
      REAL*8 uid, vid, wid, tid, ro0d, u0d, v0d, w0d, t0d
      REAL*8 cg, mg, vg, pg, roa, roinf
      REAL*8 vgd, pgd
      REAL*8 b, f, df, tg, rog, rpg, p0, vn0, vng, pi, vni, wni, wn0, 
     +       residug, dwng
      REAL*8 bd, fd, dfd, tgd, rogd, p0d, vngd, pid, vnid, wnid, wn0d, 
     +       dwngd
      REAL*8 newtonmax, tolnewton
      REAL*8 roc0l, ril, d0nl, d0n2l, vngl, residul
      REAL*8 ventx, venty, ventz
C
C...  Tableaux de travail locaux
      REAL*8 roc0(size_work), usd0n(size_work), usd0n2(size_work), ri(
     +       size_work), wng(size_work)
      LOGICAL nan
      INTEGER*4 indbci, ithread
C    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER*4 inddm, i_1, j_1, k_1
C    adresse interface pour tableau metric
      INTEGER*4 indmtr, i_3, j_3, k_3
C    adresse interface pour tableau vitesse entrainement
      INTEGER*4 indven, i_4, j_4, k_4
      EXTERNAL SHAPE_TAB_MTR
      INTRINSIC MOD
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      REAL*8 abs0
      REAL*8 abs1
      REAL*8 abs2
      REAL*8 abs3
      REAL*8 abs4
      REAL*8 abs5
      REAL*8 arg1
      REAL*8 arg1d
      REAL*8 pwr1
      REAL*8 pwr1d
      INTEGER ii1
      REAL*8 y12
      REAL*8 y11
      REAL*8 y10
      REAL*8 wngd(size_work)
      REAL*8 roc0d(size_work)
      REAL*8 rid(size_work)
      REAL*8 y9
      REAL*8 y8
      REAL*8 y7
      REAL*8 y6
      REAL*8 y5
      REAL*8 y4
      REAL*8 y3
      REAL*8 y2
      REAL*8 y1
C
C......determine la forme des tableuz metrique en fonction de la nature du domaine
      CALL SHAPE_TAB_MTR(neq_mtr, param_int, idir, ic, jc, kc, kc_vent, 
     +                   ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale)
C
C
      snorm = -1.
C!! premiere rangee = CL
C!! rangee suivante pour que : Phi_L + Phi_R = 2 * state
      IF (MOD(idir, 2) .EQ. 0) snorm = 1.
      gam = param_real(1)
      gam1 = gam - 1.
      gam1_1 = 1./gam1
      gam2 = gam/gam1
      rgp = param_real(2)*gam1
      newtonmax = param_int(65)
      tolnewton = param_real(37)
      c0 = 1./c6
      c1 = -((c4+c5)*c0)
      c2 = -(c6*c0)
Cwrite(*,'(a,7i4)')'BC', ind_loop, idir
      c3 = (2.-c5-c4)*c0
Cidir
C
      IF (idir .EQ. 1) THEN
Cparam_int(36)
        IF (param_int(36) .EQ. 5) THEN
CConstruction premier vecteur pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              li = 1
CInit Newton
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(li) = wn0d
              wng(li) = wn0
              residug = 1.e+20
              nitnwt = 0
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y1 = dwng/wng(li)
                ELSE
                  y1 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y1) THEN
                  residug = y1
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
CMise a jour next rank
              ropd(l, 5) = tgd
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs0 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs0 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs0 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
C
C
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              li = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
C write(*,*) ventx, venty, ventz, j,k
Cresolution Newton             
              wngd(li) = wn0d
              wng(li) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y2 = dwng/wng(li)
                ELSE
                  y2 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y2) THEN
                  residug = y2
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
CMise a jour next rank
              ropd(l, 6) = 0.D0
C
C
C
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 2) THEN
C
C
C
C
C
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              li = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(li) = wn0d
              wng(li) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y3 = dwng/wng(li)
                ELSE
                  y3 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y3) THEN
                  residug = y3
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
CMise a jour next rank
              ropd(l, 5) = tgd
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs1 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs1 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs1 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
C
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              li = 1
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
Cresolution Newton             
              wngd(li) = wn0d
              wng(li) = wn0
              residug = 1.e+20
              nitnwt = 0.
              DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. 
     +                  newtonmax)
                nitnwt = nitnwt + 1
                residug = 0.
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y4 = dwng/wng(li)
                ELSE
                  y4 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y4) THEN
                  residug = y4
                ELSE
                  residug = residug
                END IF
              ENDDO
C
C
C End Newton
CMise a jour first rank
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
CMise a jour next rank
              ropd(l, 6) = 0.D0
C
C
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 3) THEN
C
C
C
C
        incj = param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (4)+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(
     +            5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y5 = dwng/wng(li)
                ELSE
                  y5 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y5) THEN
                  residug = y5
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
Ci
CEnd Newton
CMise a jour first rank
            li = 0
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
            ENDDO
Ci
CMise a jour next rank
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs2 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs2 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs2 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
Ci
Cj
C
Ck
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (4)+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(
     +            5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y6 = dwng/wng(li)
                ELSE
                  y6 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y6) THEN
                  residug = y6
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
Ci
CEnd Newton
CMise a jour first rank
            li = 0
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
              ropd(l, 6) = 0.D0
            ENDDO
C
C
Ci
CMise a jour next rank
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 4) THEN
C
Ci
Cj
C
Ck
C
C
C
        incj = -param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (3)+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+
     +            4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(3)+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y7 = dwng/wng(li)
                ELSE
                  y7 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y7) THEN
                  residug = y7
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
Ci
CEnd Newton 
CMise a jour first rank
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
            ENDDO
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs3 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs3 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs3 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
Ci
Cj
C
Ck
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO k=ind_loop(5),ind_loop(6)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Ci
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+
     +            3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)
     +            *param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop
     +            (3)+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+
     +            4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (
     +            ind_loop(3)+param_int(15+3)-1)*param_int(15+1) + (k+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + incj
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y8 = dwng/wng(li)
                ELSE
                  y8 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y8) THEN
                  residug = y8
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
Ci
CEnd Newton 
CMise a jour first rank
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
              ropd(l, 6) = 0.D0
            ENDDO
C
C
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 5) THEN
C
Ci
Cj
C
Ck
C
C
C
        inck = param_int(0)*param_int(0+1)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y9 = dwng/wng(li)
                ELSE
                  y9 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y9) THEN
                  residug = y9
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
CEnd Newton 
CMise a jour first rank
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
            ENDDO
CMise a jour next rank
C
            DO k=ind_loop(5),ind_loop(6)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs4 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs4 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs4 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
C
Cj
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y10 = dwng/wng(li)
                ELSE
                  y10 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y10) THEN
                  residug = y10
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
CEnd Newton 
CMise a jour first rank
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
              ropd(l, 6) = 0.D0
            ENDDO
C
C
CMise a jour next rank
C
            DO k=ind_loop(5),ind_loop(6)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE
C
C
Cj
C
C
C
C
        inck = -(param_int(0)*param_int(0+1))
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y11 = dwng/wng(li)
                ELSE
                  y11 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y11) THEN
                  residug = y11
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
CEnd Newton
CMise a jour first rank
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
            ENDDO
CMise a jour next rank
C
            DO k=ind_loop(5)+1,ind_loop(6)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
Cif(rop(l,1).le.0.3*rop(l0,1)) then  ! protection pour eviter valeur negative de ro et t
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
                IF (rop(l, 1)/rop(l0, 1) - 1. .GE. 0.) THEN
                  abs5 = rop(l, 1)/rop(l0, 1) - 1.
                ELSE
                  abs5 = -(rop(l, 1)/rop(l0, 1)-1.)
                END IF
C
C
                IF (abs5 .GE. 0.7) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                END IF
              ENDDO
            ENDDO
          ENDDO
        ELSE
          DO ii1=1,size_work
            rid(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            roc0d(ii1) = 0.0
          ENDDO
          DO ii1=1,size_work
            wngd(ii1) = 0.0
          ENDDO
C
Cj
C
C
CInit Newton
CConstruction premier vecteru pour Newton
C OUT: roc0(*), usd0n(*),usd0n2(*), ri(*), wng(*)
          DO j=ind_loop(3),ind_loop(4)
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0d = ropd(l1, 2)
              u0 = rop(l1, 2)
              v0d = ropd(l1, 3)
              v0 = rop(l1, 3)
              w0d = ropd(l1, 4)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C. ... Non-linear equation for the normal velocity => Newton
C ...  Implementation elsA 
              vnid = tnx*uid + tny*vid + tnz*wid
              vni = ui*tnx + vi*tny + wi*tnz
C rho*c
Csans dimension: produit scalaire direction vitesse . normale
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d(li) = 0.D0
              ELSE
                roc0d(li) = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0(li) = SQRT(arg1)
              usd0n(li) = 1./(d0x(li)*tnx+d0y(li)*tny+d0z(li)*tnz)
              usd0n2(li) = usd0n(li)**2
C ...   Inner caracteristic variable
C ...   Relative normal velocity        
              wnid = vnid
              wni = vni - qen
              rid(li) = pid + roc0d(li)*wni + roc0(li)*wnid
              ri(li) = pi + roc0(li)*wni
C ...   Newton Initialization for the relative normal velocity 
              wn0d = tnx*u0d + tny*v0d + tnz*w0d
              wn0 = u0*tnx + v0*tny + w0*tnz - qen
              wngd(li) = wn0d
              wng(li) = wn0
            ENDDO
Cresolution Newton
C
            residug = 1.e+20
            nitnwt = 0.
            DO WHILE (residug .GT. tolnewton .AND. nitnwt .LT. newtonmax
     +         )
              nitnwt = nitnwt + 1
C
              li = 0
              residug = 0.
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +            param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +            param_int(5+4)-1)*param_int(5+2)
                ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +            param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +            param_int(15+4)-1)*param_int(15+2)
                l1 = l + inck
                li = li + 1
                li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roi = rop(l1, 1)
                ui = rop(l1, 2)
                vi = rop(l1, 3)
                wi = rop(l1, 4)
                ti = rop(l1, 5)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0 = rop(l1, 5)
                p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
                ventx = ventijk(ldp, 1)
                venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
                ventz = ventijk(ldp, kc_vent)*ck_vent
                qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C... Newton for the relative normal velocity
                bd = -(usd0n2(li)*2*(wng(li)+qen)*wngd(li)/(2.*ha(li)
     +            ))
                b = 1. - (wng(li)+qen)**2*usd0n2(li)/(2.*ha(li))
                IF (0.2 .LT. b) THEN
                  b = b
                ELSE
                  b = 0.2
                  bd = 0.0
                END IF
C
                IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2
     +              ))) THEN
                  pwr1d = gam2*b**(gam2-1)*bd
                ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                  pwr1d = bd
                ELSE
                  pwr1d = 0.0
                END IF
                pwr1 = b**gam2
                pgd = pa(li)*pwr1d
                pg = pa(li)*pwr1
C      nan = isnan(pg)
C      if(nan)   write(*,*)'fuck Nan inflow_newton',pa(li),b,gam2
C
                rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)
     +            **2
                rog = gam2*pg/(ha(li)*b)
C
                fd = pgd + roc0d(li)*wng(li) + roc0(li)*wngd(li) - 
     +            rid(li)
                f = pg + roc0(li)*wng(li) - ri(li)
                dfd = roc0d(li) - usd0n2(li)*(rogd*(wng(li)+qen)+rog*
     +            wngd(li))
                df = roc0(li) - rog*(wng(li)+qen)*usd0n2(li)
                dwngd = -((fd*df-f*dfd)/df**2)
                dwng = -(f/df)
                wngd(li) = wngd(li) + dwngd
                wng(li) = wng(li) + dwng
                IF (dwng/wng(li) .GE. 0.) THEN
                  y12 = dwng/wng(li)
                ELSE
                  y12 = -(dwng/wng(li))
                END IF
                IF (residug .LT. y12) THEN
                  residug = y12
                ELSE
                  residug = residug
                END IF
              ENDDO
            ENDDO
C
C
CEnd Newton
CMise a jour first rank
C
            li = 0
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = li + 1
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
CC    IN : rop
CC    OUT: roi,ui,vi,wi,Ti,pi (etat intern)
CC    OUT: ro0,u0,v0,w0,T0,pi (etat extern)
CC    OUT: tcx,tcy,tcz, tnx,tny,tnz
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roi = rop(l1, 1)
              ui = rop(l1, 2)
              vi = rop(l1, 3)
              wi = rop(l1, 4)
              ti = rop(l1, 5)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0 = rop(l1, 5)
              p0 = ro0*rgp*t0
CC    In : tnx,tny,tnz, c_ale, ventijk
CC    OUT: qen (vitesse entrainememnt)
              ventx = ventijk(ldp, 1)
              venty = ventijk(ldp, 2)
Cwrite(*,*) ventx, venty, ventz, j,k
              ventz = ventijk(ldp, kc_vent)*ck_vent
              qen = (ventx*tnx+venty*tny+ventz*tnz)*c_ale
C
C
C
C... End of Newton and building of the variables
              vngd = wngd(li)
              vng = wng(li) + qen
C...      Absolute velocity module
              vgd = usd0n(li)*vngd
              vg = vng*usd0n(li)
              bd = -(usd0n2(li)*2*vng*vngd/(2.*ha(li)))
              b = 1. - vng**2*usd0n2(li)/(2.*ha(li))
              IF (0.2 .LT. b) THEN
                b = b
              ELSE
                b = 0.2
                bd = 0.0
              END IF
C
              IF (b .GT. 0.0 .OR. (b .LT. 0.0 .AND. gam2 .EQ. INT(gam2))
     +        ) THEN
                pwr1d = gam2*b**(gam2-1)*bd
              ELSE IF (b .EQ. 0.0 .AND. gam2 .EQ. 1.0) THEN
                pwr1d = bd
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = b**gam2
              pgd = pa(li)*pwr1d
              pg = pa(li)*pwr1
              rogd = (gam2*pgd*ha(li)*b-gam2*pg*ha(li)*bd)/(ha(li)*b)**2
              rog = gam2*pg/(ha(li)*b)
Cif(j*k.eq.1)write(*,'(a,4f16.6,2i4)')'verif',vg,pg,rog,Tg,j,k
              tgd = (pgd*rog*rgp-pg*rgp*rogd)/(rog*rgp)**2
              tg = pg/(rog*rgp)
C
              ropd(l, 1) = rogd
              ropd(l, 2) = d0x(li)*vgd
              ropd(l, 3) = d0y(li)*vgd
              ropd(l, 4) = d0z(li)*vgd
              ropd(l, 5) = tgd
              ropd(l, 6) = 0.D0
            ENDDO
C
C
CMise a jour next rank
C
            DO k=ind_loop(5)+1,ind_loop(6)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = c3*ropd(l0, 1) + c1*ropd(l1, 1) + c2*ropd(
     +            l2, 1)
C
                IF (rop(l, 1) .LE. 0.3*rop(l0, 1)) THEN
C protection pour eviter valeur negative de ro et t
                  ropd(l, 1) = ropd(l0, 1)
                  ropd(l, 2) = ropd(l0, 2)
                  ropd(l, 3) = ropd(l0, 3)
                  ropd(l, 4) = ropd(l0, 4)
                  ropd(l, 5) = ropd(l0, 5)
                  ropd(l, 6) = ropd(l0, 6)
                ELSE
                  ropd(l, 2) = c3*ropd(l0, 2) + c1*ropd(l1, 2) + c2*ropd
     +              (l2, 2)
                  ropd(l, 3) = c3*ropd(l0, 3) + c1*ropd(l1, 3) + c2*ropd
     +              (l2, 3)
                  ropd(l, 4) = c3*ropd(l0, 4) + c1*ropd(l1, 4) + c2*ropd
     +              (l2, 4)
                  ropd(l, 5) = c3*ropd(l0, 5) + c1*ropd(l1, 5) + c2*ropd
     +              (l2, 5)
                  ropd(l, 6) = c3*ropd(l0, 6) + c1*ropd(l1, 6) + c2*ropd
     +              (l2, 6)
                END IF
              ENDDO
            ENDDO
          ENDDO
        END IF
      END IF
      END

