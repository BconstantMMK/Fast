C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) - 28 May 2018 09:28
C
C  Differentiation of bvbs_outpres in forward (tangent) mode:
C   variations   of useful results: rop
C   with respect to varying inputs: rop
C   RW status of diff variables: rop:in-out
C
C
C
C
C
C
C
C
C
C
C
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 ao√ªt 2013) $
C     $Revision: 35 $
C     $Author: IvanMary $
C***********************************************************************
      SUBROUTINE BVBS_OUTPRES_D(idir, lrhs, neq_mtr, param_int, ind_loop
     +                          , param_real, c4, c5, c6, ventijk, tijk
     +                          , rop, ropd, pext, size_data, inc_bc)
      IMPLICIT NONE
C
Cdo  nd = 1, size_data
C   pext(nd) = data_pres(nd)
Cenddo
Ck_piv = data_pres(size_data+1)
CSeule la valeur de k_vent et ck_vent a un sens dans cet appel
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER*4 idir, lrhs, neq_mtr, ind_loop(6), param_int(0:*)
      INTEGER*4 size_data, inc_bc(3)
      REAL*8 rop(param_int(41), param_int(36))
      REAL*8 ropd(param_int(41), param_int(36))
      REAL*8 ventijk(param_int(44), param_int(40))
      REAL*8 tijk(param_int(43), neq_mtr)
      REAL*8 c4, c5, c6, param_real(0:*)
C
C...  pext contient les donnees CGNS pour la sortie subsonique
      REAL*8 pext(size_data)
C
C Var local
CINTEGER*4 k_piv,nd
      INTEGER*4 l, lij, lr, lp, i, j, k, l1, l2, ic, jc, kc, kc_vent, 
     +          ldp, lmtr, l0, incj, inck, li, nd
C
C
      REAL*8 ro, u, v, w, t, nut, c6inv, c0, c1, c2, c3, roe, rue, rve, 
     +       rwe, ete, ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale, tcx, tcy
     +       , tcz, qref1, qref2, qref3, qref4, qref5, r, p, c, snorm, 
     +       nue, gam1, gam1_1, gam, cvinv, gamm1_1, gamm1, sni, tn, qn
     +       , qen, eigv1, eigv2, eigv3, eigv4, eigv5, qvar1, qvar2, 
     +       qvar3, qvar4, qvar5, svar1, svar2, svar3, svar4, svar5, 
     +       rvar1, rvar2, rvar3, rvar4, rvar5, roext, ruext, rvext, 
     +       rwext, etext, roint, ruint, rvint, rwint, etint, s_1, roi, 
     +       rui, rvi
      REAL*8 rwi, eti, tnx, tny, tnz, ri, roinv, sn, roe_inv
      REAL*8 roid
      REAL*8 pi, ci, roci, dqn, rog, ug, vg, wg, tg, pg, rgp, roc0
      REAL*8 pid, dqnd, rogd, ugd, vgd, wgd, roc0d
CREAL*8 pext(size_data)
      REAL*8 ui, vi, wi, ti, ro0, u0, v0, w0, t0, p0
      REAL*8 uid, vid, wid, tid, ro0d, t0d, p0d
C
C...  Tableau de travail local
      INTEGER*4 indbci
C    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER*4 inddm, i_1, j_1, k_1
C    adresse interface pour tableau metric
      INTEGER*4 indmtr, i_3, j_3, k_3
C    adresse interface pour tableau vitesse entrainement
      INTEGER*4 indven, i_4, j_4, k_4
      EXTERNAL SHAPE_TAB_MTR
      INTRINSIC MOD
      INTRINSIC SQRT
      REAL*8 arg1
      REAL*8 arg1d
C
C......determine la forme des tableuz metrique en fonction de la nature du domaine
      CALL SHAPE_TAB_MTR(neq_mtr, param_int, idir, ic, jc, kc, kc_vent, 
     +                   ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale)
C
      snorm = -1.
      IF (MOD(idir, 2) .EQ. 0) snorm = 1.
      gam = param_real(1)
      gam1 = param_real(1) - 1.
      gam1_1 = 1./gam1
C semble inutile car pas d extrapolation ordre 3 dans la 2eme couche de ghost cells 
      rgp = param_real(2)*gam1
      c0 = 1./c6
      c1 = -((c4+c5)*c0)
      c2 = -(c6*c0)
      c3 = (2.-c5-c4)*c0
Cidir
C
      IF (idir .EQ. 1) THEN
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(2)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(2)+1+param_int(5+3)-1)*param_int(5) +
     +          (j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-
     +          1)*param_int(5+2)
              ldp = 1 + (ind_loop(2)+1+param_int(15+3)-1)*param_int(15) 
     +          + (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + 1
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
C
              l0 = l
              l2 = l + 2
              DO i=ind_loop(1),ind_loop(2)-1
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
                ropd(l, 6) = ropd(l0, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 2) THEN
C
C
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
          DO k=ind_loop(5),ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
C
              l = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (ind_loop(1)+param_int(5+3)-1)*param_int(5) + (
     +          j+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15) + 
     +          (j+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l - 1
              li = 1 + (j-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
C
              l0 = l
              l2 = l - 2
              DO i=ind_loop(1)+1,ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
                ropd(l, 6) = ropd(l0, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 3) THEN
C
C
C
C
        incj = param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO k=ind_loop(5),ind_loop(6)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
            ENDDO
Ci
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
Ci
Cj
Ck
C
          DO k=ind_loop(5),ind_loop(6)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(4
     +          )+1+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)
     +          -1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          4)+1+param_int(15+3)-1)*param_int(15+1) + (k+param_int(
     +          15+4)-1)*param_int(15+2)
              l1 = l + incj
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
            ENDDO
Ci
C
            DO j=ind_loop(3),ind_loop(4)-1
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(4)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
                ropd(l, 6) = ropd(l0, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 4) THEN
C
Ci
Cj
Ck
C
C
C
        incj = -param_int(0)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO k=ind_loop(5),ind_loop(6)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
            ENDDO
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
Ci
Cj
Ck
C
          DO k=ind_loop(5),ind_loop(6)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0+3)
     +          -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (ind_loop(3
     +          )+param_int(5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1
     +          )*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (ind_loop(
     +          3)+param_int(15+3)-1)*param_int(15+1) + (k+param_int(15+
     +          4)-1)*param_int(15+2)
              l1 = l + incj
              li = 1 + (i-inc_bc(2)) + (k-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
            ENDDO
Ci
C
            DO j=ind_loop(3)+1,ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (ind_loop(3)+param_int(0
     +            +3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0
     +            )*param_int(0+1)
                l1 = l0 + incj
                l2 = l0 + 2*incj
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
                ropd(l, 6) = ropd(l0, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE IF (idir .EQ. 5) THEN
C
Ci
Cj
Ck
C
C
C
C
        inck = param_int(0)*param_int(0+1)
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
            ENDDO
          ENDDO
C
          DO k=ind_loop(5),ind_loop(6)-1
            DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
          DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(6)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(6)+1+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+1+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
            ENDDO
          ENDDO
C
          DO k=ind_loop(5),ind_loop(6)-1
            DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(6)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
C ... Implementation elsA       
                tcx = tijk(lmtr, ic)*ci_mtr*snorm
                tcy = tijk(lmtr, jc)*cj_mtr*snorm
                tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
                arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                sn = SQRT(arg1)
C
                s_1 = 1./sn
                IF (sn .EQ. 0.) THEN
                  tnx = 1.
                  tny = 0.
                  tnz = 0.
                ELSE
                  tnx = tcx*s_1
                  tny = tcy*s_1
                  tnz = tcz*s_1
                END IF
C
C ... Inner state 
                roid = ropd(l1, 1)
                roi = rop(l1, 1)
                uid = ropd(l1, 2)
                ui = rop(l1, 2)
                vid = ropd(l1, 3)
                vi = rop(l1, 3)
                wid = ropd(l1, 4)
                wi = rop(l1, 4)
                tid = ropd(l1, 5)
                ti = rop(l1, 5)
                pid = rgp*(roid*ti+roi*tid)
                pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
                ro0d = ropd(l1, 1)
                ro0 = rop(l1, 1)
                u0 = rop(l1, 2)
                v0 = rop(l1, 3)
                w0 = rop(l1, 4)
                t0d = ropd(l1, 5)
                t0 = rop(l1, 5)
                p0d = rgp*(ro0d*t0+ro0*t0d)
                p0 = ro0*rgp*t0
C ...  Implementation elsA 
                arg1d = gam*(ro0d*p0+ro0*p0d)
                arg1 = ro0*gam*p0
                IF (arg1 .EQ. 0.0) THEN
                  roc0d = 0.D0
                ELSE
                  roc0d = arg1d/(2.0*SQRT(arg1))
                END IF
                roc0 = SQRT(arg1)
                dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
                dqn = (pext(li)-pi)/roc0
                rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**
     +            2.*dqn*roc0d)/roc0**2
                rog = roi + ro0**2.*dqn/roc0
C
                ugd = uid - tnx*dqnd
                ug = ui - dqn*tnx
                vgd = vid - tny*dqnd
                vg = vi - dqn*tny
                wgd = wid - tnz*dqnd
                wg = wi - dqn*tnz
                ropd(l, 1) = rogd
                ropd(l, 2) = ugd
                ropd(l, 3) = vgd
                ropd(l, 4) = wgd
                ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
                ropd(l, 6) = ropd(l1, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      ELSE
C
C
C
C
        inck = -(param_int(0)*param_int(0+1))
Cparam_int(36)
C
        IF (param_int(36) .EQ. 5) THEN
          DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
            ENDDO
          ENDDO
C
          DO k=ind_loop(5)+1,ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
              ENDDO
            ENDDO
          ENDDO
        ELSE
C
          DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
            DO i=ind_loop(1),ind_loop(2)
C
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (ind_loop(5)+param_int(0+4)-1)*param_int(
     +          0)*param_int(0+1)
              lmtr = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+
     +          param_int(5+3)-1)*param_int(5+1) + (ind_loop(5)+
     +          param_int(5+4)-1)*param_int(5+2)
              ldp = 1 + (i+param_int(15+3)-1)*param_int(15) + (j+
     +          param_int(15+3)-1)*param_int(15+1) + (ind_loop(6)+
     +          param_int(15+4)-1)*param_int(15+2)
              l1 = l + inck
              li = 1 + (i-inc_bc(2)) + (j-inc_bc(3))*inc_bc(1)
C ... Implementation elsA       
              tcx = tijk(lmtr, ic)*ci_mtr*snorm
              tcy = tijk(lmtr, jc)*cj_mtr*snorm
              tcz = tijk(lmtr, kc)*ck_mtr*snorm
C
              arg1 = tcx*tcx + tcy*tcy + tcz*tcz
              sn = SQRT(arg1)
C
              s_1 = 1./sn
              IF (sn .EQ. 0.) THEN
                tnx = 1.
                tny = 0.
                tnz = 0.
              ELSE
                tnx = tcx*s_1
                tny = tcy*s_1
                tnz = tcz*s_1
              END IF
C
C ... Inner state 
              roid = ropd(l1, 1)
              roi = rop(l1, 1)
              uid = ropd(l1, 2)
              ui = rop(l1, 2)
              vid = ropd(l1, 3)
              vi = rop(l1, 3)
              wid = ropd(l1, 4)
              wi = rop(l1, 4)
              tid = ropd(l1, 5)
              ti = rop(l1, 5)
              pid = rgp*(roid*ti+roi*tid)
              pi = roi*rgp*ti
C ... linearization state = inner state (elsA-like)
              ro0d = ropd(l1, 1)
              ro0 = rop(l1, 1)
              u0 = rop(l1, 2)
              v0 = rop(l1, 3)
              w0 = rop(l1, 4)
              t0d = ropd(l1, 5)
              t0 = rop(l1, 5)
              p0d = rgp*(ro0d*t0+ro0*t0d)
              p0 = ro0*rgp*t0
C ...  Implementation elsA 
              arg1d = gam*(ro0d*p0+ro0*p0d)
              arg1 = ro0*gam*p0
              IF (arg1 .EQ. 0.0) THEN
                roc0d = 0.D0
              ELSE
                roc0d = arg1d/(2.0*SQRT(arg1))
              END IF
              roc0 = SQRT(arg1)
              dqnd = (-(pid*roc0)-(pext(li)-pi)*roc0d)/roc0**2
              dqn = (pext(li)-pi)/roc0
              rogd = roid + ((2.*ro0*ro0d*dqn+ro0**2.*dqnd)*roc0-ro0**2.
     +          *dqn*roc0d)/roc0**2
              rog = roi + ro0**2.*dqn/roc0
C
              ugd = uid - tnx*dqnd
              ug = ui - dqn*tnx
              vgd = vid - tny*dqnd
              vg = vi - dqn*tny
              wgd = wid - tnz*dqnd
              wg = wi - dqn*tnz
              ropd(l, 1) = rogd
              ropd(l, 2) = ugd
              ropd(l, 3) = vgd
              ropd(l, 4) = wgd
              ropd(l, 5) = -(pext(li)*rgp*rogd/(rog*rgp)**2)
              ropd(l, 6) = ropd(l1, 6)
            ENDDO
          ENDDO
C
          DO k=ind_loop(5)+1,ind_loop(6)
            DO j=ind_loop(3),ind_loop(4)
CDEC$ IVDEP
              DO i=ind_loop(1),ind_loop(2)
C
                l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +            param_int(0+1)
                l0 = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +            param_int(0) + (ind_loop(5)+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1)
                l1 = l0 + inck
                l2 = l0 + 2*inck
                ropd(l, 1) = ropd(l0, 1)
                ropd(l, 2) = ropd(l0, 2)
                ropd(l, 3) = ropd(l0, 3)
                ropd(l, 4) = ropd(l0, 4)
                ropd(l, 5) = ropd(l0, 5)
                ropd(l, 6) = ropd(l0, 6)
              ENDDO
            ENDDO
          ENDDO
        END IF
      END IF
      END

