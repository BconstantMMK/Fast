C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) - 28 May 2018 09:28
C
C  Differentiation of fluausm_lamin_o3_2d in forward (tangent) mode:
C   variations   of useful results: drodm
C   with respect to varying inputs: rop
C   RW status of diff variables: rop:in drodm:out
C
C
C
C
C
C
C
C
C
C
C
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 ao√ªt 2013) $
C     $Revision: 64 $
C     $Author: IvanMary $
C***********************************************************************
      SUBROUTINE FLUAUSM_LAMIN_O3_2D_D(ndom, ithread, param_int, 
     +                                 param_real, ind_dm, ind_loop, 
     +                                 ijkv_bloc, ijkv_cache, 
     +                                 synchro_send_sock, 
     +                                 synchro_send_th, 
     +                                 synchro_receive_sock, 
     +                                 synchro_receive_th, ibloc, jbloc
     +                                 , kbloc, icache, jcache, kcache, 
     +                                 rop, ropd, drodm, drodmd, wig, 
     +                                 venti, ventj, ventk, ti, tj, tk, 
     +                                 vol, xmut)
      IMPLICIT NONE
C
Climiteur 'minmod'
C
C
Cdo k
C
      REAL souszero
      PARAMETER (souszero=-1e-12)
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER*4 ndom, ithread, nptpsi, icache, jcache, kcache, ibloc, 
     +          jbloc, kbloc, ijkv_bloc(3), ijkv_cache(3), ind_loop(6), 
     +          ind_dm(6), synchro_send_sock(3), synchro_send_th(3), 
     +          synchro_receive_sock(3), synchro_receive_th(3), 
     +          param_int(0:*)
C
      REAL*8 xmut(param_int(41))
      REAL*8 rop(param_int(41)*param_int(36))
      REAL*8 ropd(param_int(41)*param_int(36))
      REAL*8 drodm(param_int(41)*param_int(36))
      REAL*8 drodmd(param_int(41)*param_int(36))
      REAL*8 wig(param_int(41)*3)
      REAL*8 venti(param_int(44)*param_int(40))
      REAL*8 ventj(param_int(44)*param_int(40))
      REAL*8 ventk(param_int(44)*param_int(40))
C
      REAL*8 ti(param_int(43)*param_int(37)), tj(param_int(43)*param_int
     +       (37)), tk(param_int(43)*param_int(38))
      REAL*8 vol(param_int(43))
C
      REAL*8 param_real(0:*)
C
C Var loc
      INTEGER*4 inc, incmax, l, lt, i, j, k, incmax2, nm, nm2, np, l0, 
     +          lt0, inci, incj, inck, ci, cj, lij, ltij, inci_mtr, 
     +          incj_mtr, inck_mtr, icorr, jcorr, ls, v1, v2, v3, v4, v5
     +          , v6, wig_i, wig_j, wig_k, lt200, lt100, lt010, lt210, 
     +          lt020, lt110, lt002, lt012, lt102, lt001, lt021, lt201, 
     +          lt120, lvo, lvo200, lvo020, lvo002, vslp, lvol, lvor, ir
     +          , il, l200, l100, l010, l020, l110, l101, l011, v1mtr, 
     +          v2mtr, v3mtr, l001, l002, l210, l220, l201, l202, l021, 
     +          l022, l120, l102, l012
C
      REAL*8 c1, c2, c3, c4, c5, c6, c4sa, c5sa, c6sa, si, sj, sk, qm, 
     +       qp, tcx, tcy, tcz, tc, r1, h1, rou1, rov1, row1, r2, h2, 
     +       rou2, rov2, row2, gam, gam1, gam2, gam3, gam4, qn1, qn2, u
     +       , tdu, p1p2, roref, uref, tam, tam1, qm1, qm2, qm3, qm4, 
     +       qm5, qm6, qp1, qp2, qp3, qp4, qp5, qp6, mut1, mut2, flu1, 
     +       flu2, flu3, flu4, flu5, flu6, p1, p2, qen, sigma_1, ck_vent
     +       , div, f1, f2, f3, f4, f5, f6, fv, fv5, volinv, test
      REAL*8 cmus1, temp01, coesut, tix, tiy, tiz, tix1, tiy1, tiz1, tjx
     +       , tjy, tjz, tjx1, tjy1, tjz1, tkx, tky, tkz, tkx1, tky1, 
     +       tkz1, xmutvol, cvisq, rgp, son, c, gradu_nx, gradu_ny, 
     +       gradu_nz, gradv_nx, gradv_ny, gradv_nz, gradw_nx, gradw_ny
     +       , gradw_nz, gradt_nx, gradt_ny, gradt_nz, delp, delm, delq
     +       , slq, slp, roff, tmin_1, du, dv, dw, dp, dqn, s_1, nx, ny
     +       , nz, qn, r, v, w, h, q, r_1, psiroe, xktvol, xmulam, 
     +       xmutur, xmutot
      REAL*8 qmd, qpd, r1d, h1d, rou1d, rov1d, r2d, h2d, rou2d, rov2d, 
     +       qn1d, qn2d, ud, tdud, p1p2d, tamd, tam1d, qm1d, qm2d, qm3d
     +       , qm5d, qp1d, qp2d, qp3d, qp5d, flu1d, flu2d, flu3d, flu5d
     +       , p1d, p2d, divd, f1d, f2d, f3d, f4d, f5d, f6d, fvd, fv5d, 
     +       sond, cd, gradu_nxd, gradu_nyd, gradv_nxd, gradv_nyd, 
     +       gradt_nxd, gradt_nyd
C
C    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER_E inddm, i_1, j_1, k_1
C    adresse interface pour tableau metric
      INTEGER_E indmtr, i_3, j_3, k_3
      INTRINSIC ABS
      INTRINSIC SQRT
      INTRINSIC MAX
      REAL*8 max1
      REAL*8 max1d
      REAL*8 max2
      REAL*8 max2d
      REAL*8 max3
      REAL*8 max3d
      REAL*8 max4
      REAL*8 max4d
      REAL*8 arg1
      REAL*8 arg1d
      REAL*8 x1d
      REAL*8 x2d
      REAL*8 x3d
      REAL*8 x4d
      INTEGER ii1
      REAL*8 x4
      REAL*8 x3
      REAL*8 x2
      REAL*8 x1
C
C
CC!DIR$ ASSUME_ALIGNED xmut: 32
C
      IF (ind_loop(1) .GT. ind_loop(2)) THEN
        RETURN
      ELSE IF (ind_loop(3) .GT. ind_loop(4)) THEN
        RETURN
      ELSE IF (ind_loop(5) .GT. ind_loop(6)) THEN
        RETURN
      ELSE
C
        inci = 1
        incj = param_int(0)
        inck = param_int(0)*param_int(0+1)
C
        inci_mtr = param_int(5)
        incj_mtr = param_int(5+1)
Cmetric
        inck_mtr = param_int(5+2)
C
        lt = 1 + (1+param_int(5+3)-1)*param_int(5) + (1+param_int(5+3)-1
     +    )*param_int(5+1) + (1+param_int(5+4)-1)*param_int(5+2)
        lvo = lt
        tcx = ti(lt)
        tcy = tj(lt)
        IF (tcx .GE. 0.) THEN
          si = tcx
        ELSE
          si = -tcx
        END IF
        IF (tcy .GE. 0.) THEN
          sj = tcy
        ELSE
          sj = -tcy
        END IF
C-----Variables physiques
        volinv = 0.5/vol(lvo)
C
        gam = param_real(1)
CCv(gama-1)= R (gas parfait)
        rgp = param_real(2)*(gam-1.)
        gam1 = gam/(gam-1.)
        gam2 = 1./gam
        gam3 = gam1/param_real(10)*rgp
        gam4 = gam1/param_real(38)*rgp
C
        cmus1 = param_real(13)
        temp01 = 1./param_real(12)
        coesut = param_real(11)*(1.+cmus1*temp01)
        sigma_1 = 1./(2./3.)
C
        roref = param_real(3)
        uref = param_real(5)
C
        psiroe = param_real(34)
C!si T< 0.01Tinf, alors limiteur null
        tmin_1 = 100./param_real(6)
C
C modif suite chant metrique et suppression tc dans flux final
        c1 = 0.02*uref
C modif suite chant metrique et suppression tc dans flux final
        c2 = 0.02/(uref*roref)
C    roff MUSCL
        c3 = -2.
C
        c6 = 1./6.
        c4 = 5.*c6
        c5 = 2.*c6
        c6 = -(1.*c6)
C
C      c7     = c4/c5
C
        cvisq = 1./3
C
Ccorrection indice boucle i pour traiter l'interface ind_loop(2)+1 si necessaire
        icorr = 0
        jcorr = 0
        IF (ibloc .EQ. ijkv_bloc(1) .AND. synchro_receive_sock(1) .EQ. 0
     +      .AND. icache .EQ. ijkv_cache(1) .AND. synchro_receive_th(1) 
     +      .EQ. 0) icorr = 1
        IF (jbloc .EQ. ijkv_bloc(2) .AND. synchro_receive_sock(2) .EQ. 0
     +      .AND. jcache .EQ. ijkv_cache(2) .AND. synchro_receive_th(2) 
     +      .EQ. 0) jcorr = 1
C
        v1 = 0
        v2 = param_int(41)
        v3 = 2*param_int(41)
        v4 = 3*param_int(41)
        v5 = 4*param_int(41)
        v6 = 5*param_int(41)
C
        v1mtr = 0
        v2mtr = param_int(43)
        v3mtr = 2*param_int(43)
C
        wig_i = v1
        wig_j = v2
        wig_k = v3
C
C
C
CC!DIR$ ASSUME (mod(inck,   4) .eq. 0)
CC!DIR$ ASSUME (mod(incj,   4) .eq. 0)
CC!DIR$ ASSUME (mod(param_int(41), 4) .eq. 0)
C
        DO k=ind_loop(5),ind_loop(6)
          DO j=ind_loop(3),ind_loop(4)
C
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
CC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP
CDIR$ DISTRIBUTE POINT
            DO l=lij+1,lij+1+ind_loop(2)-ind_loop(1)
C
              lt = l - ltij
              lvo = lt
              l0 = l - incj
C.....Metrique
              tcx = tj(lt+v1mtr)
              tcy = tj(lt+v2mtr)
              arg1 = tcx*tcx + tcy*tcy
              sj = SQRT(arg1)
C
              nm = l - incj
              nm2 = l - 2*incj
              np = l + incj
C
C pente (qm) a l'interface droite et  (qp) a l'interface gauche
C qm: right state,  qp: left state
              vslp = v1
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1d = qmd
              qm1 = qm
              qp1d = qpd
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm2d = qmd
              qm2 = qm
              qp2d = qpd
              qp2 = qp
C
C qm: right state,  qp: left state
              vslp = v3
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm3d = qmd
              qm3 = qm
              qp3d = qpd
              qp3 = qp
C
C
C qm: right state,  qp: left state
              vslp = v5
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm5d = qmd
              qm5 = qm
              qp5d = qpd
              qp5 = qp
C
Cdetermination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              r1d = qp1d
              r1 = qp1
              rou1d = r1d*qp2 + r1*qp2d
              rou1 = r1*qp2
              rov1d = r1d*qp3 + r1*qp3d
              rov1 = r1*qp3
              p1d = rgp*(r1d*qp5+r1*qp5d)
              p1 = r1*qp5*rgp
Cdetermination etat droite: ro, roui, roe+p
              h1d = gam1*p1d + .5*(rou1d*qp2+rou1*qp2d+rov1d*qp3+rov1*
     +          qp3d)
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
C
              r2d = qm1d
              r2 = qm1
              rou2d = r2d*qm2 + r2*qm2d
              rou2 = r2*qm2
              rov2d = r2d*qm3 + r2*qm3d
              rov2 = r2*qm3
              p2d = rgp*(r2d*qm5+r2*qm5d)
              p2 = r2*qm5*rgp
              h2d = gam1*p2d + .5*(rou2d*qm2+rou2*qm2d+rov2d*qm3+rov2*
     +          qm3d)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
C
Cdetermination vitesse normale interface
              qn1d = tcx*qp2d + tcy*qp3d
              qn1 = qp2*tcx + qp3*tcy
C modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow
              qn2d = tcx*qm2d + tcy*qm3d
              qn2 = qm2*tcx + qm3*tcy
C
Cc^2
              cd = rgp*gam*ropd(l+v5)
              c = rgp*gam*rop(l+v5)
              arg1d = ((qn1d*qn1+qn1*qn1d)*c-qn1**2*cd)/c**2
              arg1 = qn1*qn1/c
              IF (arg1 .EQ. 0.0) THEN
                sond = 0.D0
              ELSE
                sond = arg1d/(2.0*SQRT(arg1))
              END IF
              son = SQRT(arg1)
              tamd = c3*sond
              tam = c3*son + sj
              IF (0. .LT. tam) THEN
                max1d = tamd
                max1 = tam
              ELSE
                max1 = 0.
                max1d = 0.0
              END IF
C fct amortissement: c3*Mach+1
              tam1d = c2*max1d
              tam1 = max1*c2
              ud = 0.25*(qn1d+qn2d) - tam1d*(p2-p1) - tam1*(p2d-p1d)
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x1d = ud
                x1 = u
              ELSE
                x1d = -ud
                x1 = -u
              END IF
              IF (x1 .LT. c1*sj) THEN
                tdu = c1*sj
                tdud = 0.0
              ELSE
                tdud = x1d
                tdu = x1
              END IF
C
              p1p2d = 0.5*(p1d+p2d)
              p1p2 = (p1+p2)*0.5
C
C
              flu1d = ud*(r1+r2) + u*(r1d+r2d) - tdud*(r2-r1) - tdu*(r2d
     +          -r1d)
              flu1 = u*(r1+r2) - tdu*(r2-r1)
              flu2d = ud*(rou1+rou2) + u*(rou1d+rou2d) - tdud*(rou2-rou1
     +          ) - tdu*(rou2d-rou1d) + tcx*p1p2d
              flu2 = u*(rou1+rou2) - tdu*(rou2-rou1) + tcx*p1p2
              flu3d = ud*(rov1+rov2) + u*(rov1d+rov2d) - tdud*(rov2-rov1
     +          ) - tdu*(rov2d-rov1d) + tcy*p1p2d
              flu3 = u*(rov1+rov2) - tdu*(rov2-rov1) + tcy*p1p2
              flu4 = 0.
C1=?+1; 
C3=?+2 
C2=?-1
C4=?-2
Cl341  = (i+2,j-2,k+1)
              flu5d = ud*(h1+h2) + u*(h1d+h2d) - tdud*(h2-h1) - tdu*(h2d
     +          -h1d)
              flu5 = u*(h1+h2) - tdu*(h2-h1)
              lt100 = lt + inci_mtr
              lt010 = lt + incj_mtr
              lt020 = lt - incj_mtr
              lt120 = lt + inci_mtr - incj_mtr
C
              lvor = lt
              lvol = lt020
C
              il = l - incj
              ir = l
              l220 = l - inci - incj
              l200 = l - inci
              l120 = l + inci - incj
CCalcul des vecteurs surfaces J
              l100 = l + inci
CCCCCC
CCCCCC
CCCCCC   Facette J
CCCCCC
CCCCCC
              tix = .5*(tj(lt+v1mtr)+tj(lt020+v1mtr))
              tiy = .5*(tj(lt+v2mtr)+tj(lt020+v2mtr))
              tix1 = .5*(tj(lt+v1mtr)+tj(lt010+v1mtr))
              tiy1 = .5*(tj(lt+v2mtr)+tj(lt010+v2mtr))
C
C(i,j,k) et (i,j-1,k)
              tkx = .125*(ti(lt+v1mtr)+ti(lt020+v1mtr))
              tky = .125*(ti(lt+v2mtr)+ti(lt020+v2mtr))
C(i+1,j,k) et (i+1,j-1,k)
              tkx1 = .125*(ti(lt100+v1mtr)+ti(lt120+v1mtr))
C --- Gradients en U_j (i,j,k), (i,j-1,k), (i,j-1,k-1), (i,j,k-1)
              tky1 = .125*(ti(lt100+v2mtr)+ti(lt120+v2mtr))
C
              f1d = ropd(il+v2)
              f1 = rop(il+v2)
              f2d = ropd(ir+v2)
              f2 = rop(ir+v2)
              f5d = ropd(ir+v2) + ropd(il+v2) + ropd(l220+v2) + ropd(
     +          l200+v2)
              f5 = rop(ir+v2) + rop(il+v2) + rop(l220+v2) + rop(l200+v2)
              f6d = ropd(ir+v2) + ropd(il+v2) + ropd(l120+v2) + ropd(
     +          l100+v2)
              f6 = rop(ir+v2) + rop(il+v2) + rop(l120+v2) + rop(l100+v2)
C
              gradu_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradu_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C --- Gradients en V_j
              gradu_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradu_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              f1d = ropd(il+v3)
              f1 = rop(il+v3)
              f2d = ropd(ir+v3)
              f2 = rop(ir+v3)
              f5d = ropd(ir+v3) + ropd(il+v3) + ropd(l220+v3) + ropd(
     +          l200+v3)
              f5 = rop(ir+v3) + rop(il+v3) + rop(l220+v3) + rop(l200+v3)
              f6d = ropd(ir+v3) + ropd(il+v3) + ropd(l120+v3) + ropd(
     +          l100+v3)
              f6 = rop(ir+v3) + rop(il+v3) + rop(l120+v3) + rop(l100+v3)
C
              gradv_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradv_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C --- Gradients en T_j
              gradv_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradv_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              f1d = ropd(il+v5)
              f1 = rop(il+v5)
              f2d = ropd(ir+v5)
              f2 = rop(ir+v5)
              f5d = ropd(ir+v5) + ropd(il+v5) + ropd(l220+v5) + ropd(
     +          l200+v5)
              f5 = rop(ir+v5) + rop(il+v5) + rop(l220+v5) + rop(l200+v5)
              f6d = ropd(ir+v5) + ropd(il+v5) + ropd(l120+v5) + ropd(
     +          l100+v5)
              f6 = rop(ir+v5) + rop(il+v5) + rop(l120+v5) + rop(l100+v5)
C
              gradt_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradt_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C--- assemblage flux
              gradt_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradt_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              divd = cvisq*(gradu_nxd+gradv_nyd)
              div = (gradu_nx+gradv_ny)*cvisq
              f1d = gradu_nxd - divd
              f1 = gradu_nx - div
              f2d = gradu_nyd + gradv_nxd
              f2 = gradu_ny + gradv_nx
              f4d = gradv_nyd - divd
              f4 = gradv_ny - div
C
              volinv = 1./(vol(lvor)+vol(lvol))
              xmutvol = (xmut(ir)+xmut(il))*volinv
              xktvol = xmutvol*gam3
C
              fvd = -(xmutvol*(2.*tcx*f1d+tcy*f2d))
              fv = -((2.*f1*tcx+f2*tcy)*xmutvol)
              fv5d = fvd*(rop(ir+v2)+rop(il+v2)) + fv*(ropd(ir+v2)+ropd(
     +          il+v2))
              fv5 = fv*(rop(ir+v2)+rop(il+v2))
              flu2d = flu2d + fvd
              flu2 = flu2 + fv
C
              fvd = -(xmutvol*(tcx*f2d+2.*tcy*f4d))
              fv = -((f2*tcx+2.*f4*tcy)*xmutvol)
              fv5d = fv5d + fvd*(rop(ir+v3)+rop(il+v3)) + fv*(ropd(ir+v3
     +          )+ropd(il+v3))
              fv5 = fv5 + fv*(rop(ir+v3)+rop(il+v3))
              flu3d = flu3d + fvd
              flu3 = flu3 + fv
C
              fvd = 0.5*fv5d - xktvol*(tcx*gradt_nxd+tcy*gradt_nyd)
              fv = fv5*0.5 - (gradt_nx*tcx+gradt_ny*tcy)*xktvol
              flu5d = flu5d + fvd
              flu5 = flu5 + fv
              drodmd(l+v1) = drodmd(l+v1) + flu1d
              drodmd(l0+v1) = drodmd(l0+v1) - flu1d
              drodmd(l+v2) = drodmd(l+v2) + flu2d
              drodmd(l0+v2) = drodmd(l0+v2) - flu2d
              drodmd(l+v3) = drodmd(l+v3) + flu3d
              drodmd(l0+v3) = drodmd(l0+v3) - flu3d
              drodmd(l+v5) = drodmd(l+v5) + flu5d
              drodmd(l0+v5) = drodmd(l0+v5) - flu5d
            ENDDO
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
CC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP
CDIR$ DISTRIBUTE POINT
            DO l=lij+1,lij+1+ind_loop(2)-ind_loop(1)
C
              lt = l - ltij
              lvo = lt
              l0 = l - inci
C.....Metrique
              tcx = ti(lt+v1mtr)
              tcy = ti(lt+v2mtr)
              arg1 = tcx*tcx + tcy*tcy
              si = SQRT(arg1)
C
              nm = l - inci
              nm2 = l - 2*inci
              np = l + inci
C
C pente (qm) a l'interface droite et  (qp) a l'interface gauche
C qm: right state,  qp: left state
              vslp = v1
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1d = qmd
              qm1 = qm
              qp1d = qpd
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm2d = qmd
              qm2 = qm
              qp2d = qpd
              qp2 = qp
C
C qm: right state,  qp: left state
              vslp = v3
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm3d = qmd
              qm3 = qm
              qp3d = qpd
              qp3 = qp
C
C
C qm: right state,  qp: left state
              vslp = v5
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm5d = qmd
              qm5 = qm
              qp5d = qpd
              qp5 = qp
C
Cdetermination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              r1d = qp1d
              r1 = qp1
              rou1d = r1d*qp2 + r1*qp2d
              rou1 = r1*qp2
              rov1d = r1d*qp3 + r1*qp3d
              rov1 = r1*qp3
              p1d = rgp*(r1d*qp5+r1*qp5d)
              p1 = r1*qp5*rgp
Cdetermination etat droite: ro, roui, roe+p
              h1d = gam1*p1d + .5*(rou1d*qp2+rou1*qp2d+rov1d*qp3+rov1*
     +          qp3d)
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
C
              r2d = qm1d
              r2 = qm1
              rou2d = r2d*qm2 + r2*qm2d
              rou2 = r2*qm2
              rov2d = r2d*qm3 + r2*qm3d
              rov2 = r2*qm3
              p2d = rgp*(r2d*qm5+r2*qm5d)
              p2 = r2*qm5*rgp
              h2d = gam1*p2d + .5*(rou2d*qm2+rou2*qm2d+rov2d*qm3+rov2*
     +          qm3d)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
C
Cdetermination vitesse normale interface
              qn1d = tcx*qp2d + tcy*qp3d
              qn1 = qp2*tcx + qp3*tcy
C modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow
              qn2d = tcx*qm2d + tcy*qm3d
              qn2 = qm2*tcx + qm3*tcy
C
Cc^2
              cd = rgp*gam*ropd(l+v5)
              c = rgp*gam*rop(l+v5)
              arg1d = ((qn1d*qn1+qn1*qn1d)*c-qn1**2*cd)/c**2
              arg1 = qn1*qn1/c
              IF (arg1 .EQ. 0.0) THEN
                sond = 0.D0
              ELSE
                sond = arg1d/(2.0*SQRT(arg1))
              END IF
              son = SQRT(arg1)
              tamd = c3*sond
              tam = c3*son + si
              IF (0. .LT. tam) THEN
                max2d = tamd
                max2 = tam
              ELSE
                max2 = 0.
                max2d = 0.0
              END IF
C fct amortissement: c3*Mach+1
              tam1d = c2*max2d
              tam1 = max2*c2
              ud = 0.25*(qn1d+qn2d) - tam1d*(p2-p1) - tam1*(p2d-p1d)
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x2d = ud
                x2 = u
              ELSE
                x2d = -ud
                x2 = -u
              END IF
              IF (x2 .LT. c1*si) THEN
                tdu = c1*si
                tdud = 0.0
              ELSE
                tdud = x2d
                tdu = x2
              END IF
C
              p1p2d = 0.5*(p1d+p2d)
              p1p2 = (p1+p2)*0.5
C
C
              flu1d = ud*(r1+r2) + u*(r1d+r2d) - tdud*(r2-r1) - tdu*(r2d
     +          -r1d)
              flu1 = u*(r1+r2) - tdu*(r2-r1)
              flu2d = ud*(rou1+rou2) + u*(rou1d+rou2d) - tdud*(rou2-rou1
     +          ) - tdu*(rou2d-rou1d) + tcx*p1p2d
              flu2 = u*(rou1+rou2) - tdu*(rou2-rou1) + tcx*p1p2
              flu3d = ud*(rov1+rov2) + u*(rov1d+rov2d) - tdud*(rov2-rov1
     +          ) - tdu*(rov2d-rov1d) + tcy*p1p2d
              flu3 = u*(rov1+rov2) - tdu*(rov2-rov1) + tcy*p1p2
              flu4 = 0.
C1=?+1; 
C3=?+2 
C2=?-1
C4=?-2
Cl341  = (i+2,j-2,k+1)
              flu5d = ud*(h1+h2) + u*(h1d+h2d) - tdud*(h2-h1) - tdu*(h2d
     +          -h1d)
              flu5 = u*(h1+h2) - tdu*(h2-h1)
              lt200 = lt - inci_mtr
              lt100 = lt + inci_mtr
              lt010 = lt + incj_mtr
              lt210 = lt - inci_mtr + incj_mtr
C
              lvor = lt
              lvol = lt200
C
              il = l - inci
              ir = l
              l220 = l - inci - incj
              l020 = l - incj
              l210 = l - inci + incj
CCalcul des vecteurs surfaces I
              l010 = l + incj
C
CCCCCC
CCCCCC
CCCCCC   Facette I
CCCCCC
CCCCCC
              tix = .5*(ti(lt+v1mtr)+ti(lt200+v1mtr))
              tiy = .5*(ti(lt+v2mtr)+ti(lt200+v2mtr))
              tix1 = .5*(ti(lt+v1mtr)+ti(lt100+v1mtr))
              tiy1 = .5*(ti(lt+v2mtr)+ti(lt100+v2mtr))
C
              tjx = .125*(tj(lt+v1mtr)+tj(lt200+v1mtr))
              tjy = .125*(tj(lt+v2mtr)+tj(lt200+v2mtr))
              tjx1 = .125*(tj(lt010+v1mtr)+tj(lt210+v1mtr))
C --- Gradients en U_i
              tjy1 = .125*(tj(lt010+v2mtr)+tj(lt210+v2mtr))
C
              f1d = ropd(il+v2)
              f1 = rop(il+v2)
              f2d = ropd(ir+v2)
              f2 = rop(ir+v2)
              f3d = ropd(ir+v2) + ropd(il+v2) + ropd(l220+v2) + ropd(
     +          l020+v2)
              f3 = rop(ir+v2) + rop(il+v2) + rop(l220+v2) + rop(l020+v2)
              f4d = ropd(ir+v2) + ropd(il+v2) + ropd(l210+v2) + ropd(
     +          l010+v2)
              f4 = rop(ir+v2) + rop(il+v2) + rop(l210+v2) + rop(l010+v2)
C
              gradu_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradu_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- Gradients en v_i
              gradu_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradu_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              f1d = ropd(il+v3)
              f1 = rop(il+v3)
              f2d = ropd(ir+v3)
              f2 = rop(ir+v3)
              f3d = ropd(ir+v3) + ropd(il+v3) + ropd(l220+v3) + ropd(
     +          l020+v3)
              f3 = rop(ir+v3) + rop(il+v3) + rop(l220+v3) + rop(l020+v3)
              f4d = ropd(ir+v3) + ropd(il+v3) + ropd(l210+v3) + ropd(
     +          l010+v3)
              f4 = rop(ir+v3) + rop(il+v3) + rop(l210+v3) + rop(l010+v3)
C
              gradv_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradv_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- Gradients en T_i
              gradv_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradv_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              f1d = ropd(il+v5)
              f1 = rop(il+v5)
              f2d = ropd(ir+v5)
              f2 = rop(ir+v5)
              f3d = ropd(ir+v5) + ropd(il+v5) + ropd(l220+v5) + ropd(
     +          l020+v5)
              f3 = rop(ir+v5) + rop(il+v5) + rop(l220+v5) + rop(l020+v5)
              f4d = ropd(ir+v5) + ropd(il+v5) + ropd(l210+v5) + ropd(
     +          l010+v5)
              f4 = rop(ir+v5) + rop(il+v5) + rop(l210+v5) + rop(l010+v5)
C
              gradt_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradt_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- assemblage flux
              gradt_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradt_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              divd = cvisq*(gradu_nxd+gradv_nyd)
              div = (gradu_nx+gradv_ny)*cvisq
              f1d = gradu_nxd - divd
              f1 = gradu_nx - div
              f2d = gradu_nyd + gradv_nxd
              f2 = gradu_ny + gradv_nx
              f4d = gradv_nyd - divd
              f4 = gradv_ny - div
C
              volinv = 1./(vol(lvor)+vol(lvol))
              xmutvol = (xmut(ir)+xmut(il))*volinv
              xktvol = xmutvol*gam3
C
              fvd = -(xmutvol*(2.*tcx*f1d+tcy*f2d))
              fv = -((2.*f1*tcx+f2*tcy)*xmutvol)
              fv5d = fvd*(rop(ir+v2)+rop(il+v2)) + fv*(ropd(ir+v2)+ropd(
     +          il+v2))
              fv5 = fv*(rop(ir+v2)+rop(il+v2))
              flu2d = flu2d + fvd
              flu2 = flu2 + fv
C
              fvd = -(xmutvol*(tcx*f2d+2.*tcy*f4d))
              fv = -((f2*tcx+2.*f4*tcy)*xmutvol)
              fv5d = fv5d + fvd*(rop(ir+v3)+rop(il+v3)) + fv*(ropd(ir+v3
     +          )+ropd(il+v3))
              fv5 = fv5 + fv*(rop(ir+v3)+rop(il+v3))
              flu3d = flu3d + fvd
              flu3 = flu3 + fv
C
              fvd = 0.5*fv5d - xktvol*(tcx*gradt_nxd+tcy*gradt_nyd)
              fv = fv5*0.5 - (gradt_nx*tcx+gradt_ny*tcy)*xktvol
              flu5d = flu5d + fvd
              flu5 = flu5 + fv
C
              drodmd(l+v1) = drodmd(l+v1) + flu1d
              drodmd(l0+v1) = drodmd(l0+v1) - flu1d
              drodmd(l+v2) = drodmd(l+v2) + flu2d
              drodmd(l0+v2) = drodmd(l0+v2) - flu2d
              drodmd(l+v3) = drodmd(l+v3) + flu3d
              drodmd(l0+v3) = drodmd(l0+v3) - flu3d
              drodmd(l+v5) = drodmd(l+v5) + flu5d
              drodmd(l0+v5) = drodmd(l0+v5) - flu5d
            ENDDO
C
C
            IF (icorr .EQ. 1) THEN
Cflux manquant en I
              i = ind_loop(2) + 1
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lt = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+param_int(
     +          5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1)*param_int(
     +          5+2)
C.....Metrique
              tcx = ti(lt+v1mtr)
              tcy = ti(lt+v2mtr)
              arg1 = tcx*tcx + tcy*tcy
              si = SQRT(arg1)
C
              nm = l - inci
              nm2 = l - 2*inci
              np = l + inci
C
C pente (qm) a l'interface droite et  (qp) a l'interface gauche
C qm: right state,  qp: left state
              vslp = v1
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1d = qmd
              qm1 = qm
              qp1d = qpd
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm2d = qmd
              qm2 = qm
              qp2d = qpd
              qp2 = qp
C
C qm: right state,  qp: left state
              vslp = v3
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm3d = qmd
              qm3 = qm
              qp3d = qpd
              qp3 = qp
C
C
C qm: right state,  qp: left state
              vslp = v5
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm5d = qmd
              qm5 = qm
              qp5d = qpd
              qp5 = qp
C
Cdetermination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              r1d = qp1d
              r1 = qp1
              rou1d = r1d*qp2 + r1*qp2d
              rou1 = r1*qp2
              rov1d = r1d*qp3 + r1*qp3d
              rov1 = r1*qp3
              p1d = rgp*(r1d*qp5+r1*qp5d)
              p1 = r1*qp5*rgp
Cdetermination etat droite: ro, roui, roe+p
              h1d = gam1*p1d + .5*(rou1d*qp2+rou1*qp2d+rov1d*qp3+rov1*
     +          qp3d)
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
C
              r2d = qm1d
              r2 = qm1
              rou2d = r2d*qm2 + r2*qm2d
              rou2 = r2*qm2
              rov2d = r2d*qm3 + r2*qm3d
              rov2 = r2*qm3
              p2d = rgp*(r2d*qm5+r2*qm5d)
              p2 = r2*qm5*rgp
              h2d = gam1*p2d + .5*(rou2d*qm2+rou2*qm2d+rov2d*qm3+rov2*
     +          qm3d)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
C
Cdetermination vitesse normale interface
              qn1d = tcx*qp2d + tcy*qp3d
              qn1 = qp2*tcx + qp3*tcy
C modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow
              qn2d = tcx*qm2d + tcy*qm3d
              qn2 = qm2*tcx + qm3*tcy
C
Cc^2
              cd = rgp*gam*ropd(l+v5)
              c = rgp*gam*rop(l+v5)
              arg1d = ((qn1d*qn1+qn1*qn1d)*c-qn1**2*cd)/c**2
              arg1 = qn1*qn1/c
              IF (arg1 .EQ. 0.0) THEN
                sond = 0.D0
              ELSE
                sond = arg1d/(2.0*SQRT(arg1))
              END IF
              son = SQRT(arg1)
              tamd = c3*sond
              tam = c3*son + si
              IF (0. .LT. tam) THEN
                max3d = tamd
                max3 = tam
              ELSE
                max3 = 0.
                max3d = 0.0
              END IF
C fct amortissement: c3*Mach+1
              tam1d = c2*max3d
              tam1 = max3*c2
              ud = 0.25*(qn1d+qn2d) - tam1d*(p2-p1) - tam1*(p2d-p1d)
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x3d = ud
                x3 = u
              ELSE
                x3d = -ud
                x3 = -u
              END IF
              IF (x3 .LT. c1*si) THEN
                tdu = c1*si
                tdud = 0.0
              ELSE
                tdud = x3d
                tdu = x3
              END IF
C
              p1p2d = 0.5*(p1d+p2d)
              p1p2 = (p1+p2)*0.5
C
C
              flu1d = ud*(r1+r2) + u*(r1d+r2d) - tdud*(r2-r1) - tdu*(r2d
     +          -r1d)
              flu1 = u*(r1+r2) - tdu*(r2-r1)
              flu2d = ud*(rou1+rou2) + u*(rou1d+rou2d) - tdud*(rou2-rou1
     +          ) - tdu*(rou2d-rou1d) + tcx*p1p2d
              flu2 = u*(rou1+rou2) - tdu*(rou2-rou1) + tcx*p1p2
              flu3d = ud*(rov1+rov2) + u*(rov1d+rov2d) - tdud*(rov2-rov1
     +          ) - tdu*(rov2d-rov1d) + tcy*p1p2d
              flu3 = u*(rov1+rov2) - tdu*(rov2-rov1) + tcy*p1p2
              flu4 = 0.
C1=?+1; 
C3=?+2 
C2=?-1
C4=?-2
Cl341  = (i+2,j-2,k+1)
              flu5d = ud*(h1+h2) + u*(h1d+h2d) - tdud*(h2-h1) - tdu*(h2d
     +          -h1d)
              flu5 = u*(h1+h2) - tdu*(h2-h1)
              lt200 = lt - inci_mtr
              lt100 = lt + inci_mtr
              lt010 = lt + incj_mtr
              lt210 = lt - inci_mtr + incj_mtr
C
              lvor = lt
              lvol = lt200
C
              il = l - inci
              ir = l
              l220 = l - inci - incj
              l020 = l - incj
              l210 = l - inci + incj
CCalcul des vecteurs surfaces I
              l010 = l + incj
C
CCCCCC
CCCCCC
CCCCCC   Facette I
CCCCCC
CCCCCC
              tix = .5*(ti(lt+v1mtr)+ti(lt200+v1mtr))
              tiy = .5*(ti(lt+v2mtr)+ti(lt200+v2mtr))
              tix1 = .5*(ti(lt+v1mtr)+ti(lt100+v1mtr))
              tiy1 = .5*(ti(lt+v2mtr)+ti(lt100+v2mtr))
C
              tjx = .125*(tj(lt+v1mtr)+tj(lt200+v1mtr))
              tjy = .125*(tj(lt+v2mtr)+tj(lt200+v2mtr))
              tjx1 = .125*(tj(lt010+v1mtr)+tj(lt210+v1mtr))
C --- Gradients en U_i
              tjy1 = .125*(tj(lt010+v2mtr)+tj(lt210+v2mtr))
C
              f1d = ropd(il+v2)
              f1 = rop(il+v2)
              f2d = ropd(ir+v2)
              f2 = rop(ir+v2)
              f3d = ropd(ir+v2) + ropd(il+v2) + ropd(l220+v2) + ropd(
     +          l020+v2)
              f3 = rop(ir+v2) + rop(il+v2) + rop(l220+v2) + rop(l020+v2)
              f4d = ropd(ir+v2) + ropd(il+v2) + ropd(l210+v2) + ropd(
     +          l010+v2)
              f4 = rop(ir+v2) + rop(il+v2) + rop(l210+v2) + rop(l010+v2)
C
              gradu_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradu_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- Gradients en v_i
              gradu_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradu_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              f1d = ropd(il+v3)
              f1 = rop(il+v3)
              f2d = ropd(ir+v3)
              f2 = rop(ir+v3)
              f3d = ropd(ir+v3) + ropd(il+v3) + ropd(l220+v3) + ropd(
     +          l020+v3)
              f3 = rop(ir+v3) + rop(il+v3) + rop(l220+v3) + rop(l020+v3)
              f4d = ropd(ir+v3) + ropd(il+v3) + ropd(l210+v3) + ropd(
     +          l010+v3)
              f4 = rop(ir+v3) + rop(il+v3) + rop(l210+v3) + rop(l010+v3)
C
              gradv_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradv_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- Gradients en T_i
              gradv_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradv_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              f1d = ropd(il+v5)
              f1 = rop(il+v5)
              f2d = ropd(ir+v5)
              f2 = rop(ir+v5)
              f3d = ropd(ir+v5) + ropd(il+v5) + ropd(l220+v5) + ropd(
     +          l020+v5)
              f3 = rop(ir+v5) + rop(il+v5) + rop(l220+v5) + rop(l020+v5)
              f4d = ropd(ir+v5) + ropd(il+v5) + ropd(l210+v5) + ropd(
     +          l010+v5)
              f4 = rop(ir+v5) + rop(il+v5) + rop(l210+v5) + rop(l010+v5)
C
              gradt_nxd = tix1*f2d - tix*f1d + tjx1*f4d - tjx*f3d
              gradt_nx = f2*tix1 - f1*tix + (f4*tjx1-f3*tjx)
C--- assemblage flux
              gradt_nyd = tiy1*f2d - tiy*f1d + tjy1*f4d - tjy*f3d
              gradt_ny = f2*tiy1 - f1*tiy + (f4*tjy1-f3*tjy)
C
              divd = cvisq*(gradu_nxd+gradv_nyd)
              div = (gradu_nx+gradv_ny)*cvisq
              f1d = gradu_nxd - divd
              f1 = gradu_nx - div
              f2d = gradu_nyd + gradv_nxd
              f2 = gradu_ny + gradv_nx
              f4d = gradv_nyd - divd
              f4 = gradv_ny - div
C
              volinv = 1./(vol(lvor)+vol(lvol))
              xmutvol = (xmut(ir)+xmut(il))*volinv
              xktvol = xmutvol*gam3
C
              fvd = -(xmutvol*(2.*tcx*f1d+tcy*f2d))
              fv = -((2.*f1*tcx+f2*tcy)*xmutvol)
              fv5d = fvd*(rop(ir+v2)+rop(il+v2)) + fv*(ropd(ir+v2)+ropd(
     +          il+v2))
              fv5 = fv*(rop(ir+v2)+rop(il+v2))
              flu2d = flu2d + fvd
              flu2 = flu2 + fv
C
              fvd = -(xmutvol*(tcx*f2d+2.*tcy*f4d))
              fv = -((f2*tcx+2.*f4*tcy)*xmutvol)
              fv5d = fv5d + fvd*(rop(ir+v3)+rop(il+v3)) + fv*(ropd(ir+v3
     +          )+ropd(il+v3))
              fv5 = fv5 + fv*(rop(ir+v3)+rop(il+v3))
              flu3d = flu3d + fvd
              flu3 = flu3 + fv
C
              fvd = 0.5*fv5d - xktvol*(tcx*gradt_nxd+tcy*gradt_nyd)
              fv = fv5*0.5 - (gradt_nx*tcx+gradt_ny*tcy)*xktvol
              flu5d = flu5d + fvd
              flu5 = flu5 + fv
C
              ls = l - inci
              drodmd(ls+v1) = drodmd(ls+v1) - flu1d
              drodmd(ls+v2) = drodmd(ls+v2) - flu2d
              drodmd(ls+v3) = drodmd(ls+v3) - flu3d
              drodmd(ls+v5) = drodmd(ls+v5) - flu5d
            END IF
          ENDDO
Cdo j
CComplement fluj en Jmax
C
          IF (jcorr .EQ. 1) THEN
C
            j = ind_loop(4) + 1
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
CC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP
CDIR$ DISTRIBUTE POINT
            DO l=lij+1,lij+1+ind_loop(2)-ind_loop(1)
C
              lt = l - ltij
              lvo = lt
C
C.....Metrique
              tcx = tj(lt+v1mtr)
              tcy = tj(lt+v2mtr)
              arg1 = tcx*tcx + tcy*tcy
              sj = SQRT(arg1)
C
              nm = l - incj
              nm2 = l - 2*incj
              np = l + incj
C
C pente (qm) a l'interface droite et  (qp) a l'interface gauche
C qm: right state,  qp: left state
              vslp = v1
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1d = qmd
              qm1 = qm
              qp1d = qpd
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm2d = qmd
              qm2 = qm
              qp2d = qpd
              qp2 = qp
C
C qm: right state,  qp: left state
              vslp = v3
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm3d = qmd
              qm3 = qm
              qp3d = qpd
              qp3 = qp
C
C
C qm: right state,  qp: left state
              vslp = v5
              qmd = c4*ropd(l+vslp) + c5*ropd(nm+vslp) + c6*ropd(np+vslp
     +          )
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qpd = c4*ropd(nm+vslp) + c6*ropd(nm2+vslp) + c5*ropd(l+
     +          vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm5d = qmd
              qm5 = qm
              qp5d = qpd
              qp5 = qp
C
Cdetermination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              r1d = qp1d
              r1 = qp1
              rou1d = r1d*qp2 + r1*qp2d
              rou1 = r1*qp2
              rov1d = r1d*qp3 + r1*qp3d
              rov1 = r1*qp3
              p1d = rgp*(r1d*qp5+r1*qp5d)
              p1 = r1*qp5*rgp
Cdetermination etat droite: ro, roui, roe+p
              h1d = gam1*p1d + .5*(rou1d*qp2+rou1*qp2d+rov1d*qp3+rov1*
     +          qp3d)
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
C
              r2d = qm1d
              r2 = qm1
              rou2d = r2d*qm2 + r2*qm2d
              rou2 = r2*qm2
              rov2d = r2d*qm3 + r2*qm3d
              rov2 = r2*qm3
              p2d = rgp*(r2d*qm5+r2*qm5d)
              p2 = r2*qm5*rgp
              h2d = gam1*p2d + .5*(rou2d*qm2+rou2*qm2d+rov2d*qm3+rov2*
     +          qm3d)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
C
Cdetermination vitesse normale interface
              qn1d = tcx*qp2d + tcy*qp3d
              qn1 = qp2*tcx + qp3*tcy
C modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow
              qn2d = tcx*qm2d + tcy*qm3d
              qn2 = qm2*tcx + qm3*tcy
C
Cc^2
              cd = rgp*gam*ropd(l+v5)
              c = rgp*gam*rop(l+v5)
              arg1d = ((qn1d*qn1+qn1*qn1d)*c-qn1**2*cd)/c**2
              arg1 = qn1*qn1/c
              IF (arg1 .EQ. 0.0) THEN
                sond = 0.D0
              ELSE
                sond = arg1d/(2.0*SQRT(arg1))
              END IF
              son = SQRT(arg1)
              tamd = c3*sond
              tam = c3*son + sj
              IF (0. .LT. tam) THEN
                max4d = tamd
                max4 = tam
              ELSE
                max4 = 0.
                max4d = 0.0
              END IF
C fct amortissement: c3*Mach+1
              tam1d = c2*max4d
              tam1 = max4*c2
              ud = 0.25*(qn1d+qn2d) - tam1d*(p2-p1) - tam1*(p2d-p1d)
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x4d = ud
                x4 = u
              ELSE
                x4d = -ud
                x4 = -u
              END IF
              IF (x4 .LT. c1*sj) THEN
                tdu = c1*sj
                tdud = 0.0
              ELSE
                tdud = x4d
                tdu = x4
              END IF
C
              p1p2d = 0.5*(p1d+p2d)
              p1p2 = (p1+p2)*0.5
C
C
              flu1d = ud*(r1+r2) + u*(r1d+r2d) - tdud*(r2-r1) - tdu*(r2d
     +          -r1d)
              flu1 = u*(r1+r2) - tdu*(r2-r1)
              flu2d = ud*(rou1+rou2) + u*(rou1d+rou2d) - tdud*(rou2-rou1
     +          ) - tdu*(rou2d-rou1d) + tcx*p1p2d
              flu2 = u*(rou1+rou2) - tdu*(rou2-rou1) + tcx*p1p2
              flu3d = ud*(rov1+rov2) + u*(rov1d+rov2d) - tdud*(rov2-rov1
     +          ) - tdu*(rov2d-rov1d) + tcy*p1p2d
              flu3 = u*(rov1+rov2) - tdu*(rov2-rov1) + tcy*p1p2
              flu4 = 0.
C1=?+1; 
C3=?+2 
C2=?-1
C4=?-2
Cl341  = (i+2,j-2,k+1)
              flu5d = ud*(h1+h2) + u*(h1d+h2d) - tdud*(h2-h1) - tdu*(h2d
     +          -h1d)
              flu5 = u*(h1+h2) - tdu*(h2-h1)
              lt100 = lt + inci_mtr
              lt010 = lt + incj_mtr
              lt020 = lt - incj_mtr
              lt120 = lt + inci_mtr - incj_mtr
C
              lvor = lt
              lvol = lt020
C
              il = l - incj
              ir = l
              l220 = l - inci - incj
              l200 = l - inci
              l120 = l + inci - incj
CCalcul des vecteurs surfaces J
              l100 = l + inci
CCCCCC
CCCCCC
CCCCCC   Facette J
CCCCCC
CCCCCC
              tix = .5*(tj(lt+v1mtr)+tj(lt020+v1mtr))
              tiy = .5*(tj(lt+v2mtr)+tj(lt020+v2mtr))
              tix1 = .5*(tj(lt+v1mtr)+tj(lt010+v1mtr))
              tiy1 = .5*(tj(lt+v2mtr)+tj(lt010+v2mtr))
C
C(i,j,k) et (i,j-1,k)
              tkx = .125*(ti(lt+v1mtr)+ti(lt020+v1mtr))
              tky = .125*(ti(lt+v2mtr)+ti(lt020+v2mtr))
C(i+1,j,k) et (i+1,j-1,k)
              tkx1 = .125*(ti(lt100+v1mtr)+ti(lt120+v1mtr))
C --- Gradients en U_j (i,j,k), (i,j-1,k), (i,j-1,k-1), (i,j,k-1)
              tky1 = .125*(ti(lt100+v2mtr)+ti(lt120+v2mtr))
C
              f1d = ropd(il+v2)
              f1 = rop(il+v2)
              f2d = ropd(ir+v2)
              f2 = rop(ir+v2)
              f5d = ropd(ir+v2) + ropd(il+v2) + ropd(l220+v2) + ropd(
     +          l200+v2)
              f5 = rop(ir+v2) + rop(il+v2) + rop(l220+v2) + rop(l200+v2)
              f6d = ropd(ir+v2) + ropd(il+v2) + ropd(l120+v2) + ropd(
     +          l100+v2)
              f6 = rop(ir+v2) + rop(il+v2) + rop(l120+v2) + rop(l100+v2)
C
              gradu_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradu_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C --- Gradients en V_j
              gradu_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradu_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              f1d = ropd(il+v3)
              f1 = rop(il+v3)
              f2d = ropd(ir+v3)
              f2 = rop(ir+v3)
              f5d = ropd(ir+v3) + ropd(il+v3) + ropd(l220+v3) + ropd(
     +          l200+v3)
              f5 = rop(ir+v3) + rop(il+v3) + rop(l220+v3) + rop(l200+v3)
              f6d = ropd(ir+v3) + ropd(il+v3) + ropd(l120+v3) + ropd(
     +          l100+v3)
              f6 = rop(ir+v3) + rop(il+v3) + rop(l120+v3) + rop(l100+v3)
C
              gradv_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradv_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C --- Gradients en T_j
              gradv_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradv_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              f1d = ropd(il+v5)
              f1 = rop(il+v5)
              f2d = ropd(ir+v5)
              f2 = rop(ir+v5)
              f5d = ropd(ir+v5) + ropd(il+v5) + ropd(l220+v5) + ropd(
     +          l200+v5)
              f5 = rop(ir+v5) + rop(il+v5) + rop(l220+v5) + rop(l200+v5)
              f6d = ropd(ir+v5) + ropd(il+v5) + ropd(l120+v5) + ropd(
     +          l100+v5)
              f6 = rop(ir+v5) + rop(il+v5) + rop(l120+v5) + rop(l100+v5)
C
              gradt_nxd = tix1*f2d - tix*f1d + tkx1*f6d - tkx*f5d
              gradt_nx = f2*tix1 - f1*tix + (f6*tkx1-f5*tkx)
C--- assemblage flux
              gradt_nyd = tiy1*f2d - tiy*f1d + tky1*f6d - tky*f5d
              gradt_ny = f2*tiy1 - f1*tiy + (f6*tky1-f5*tky)
C
              divd = cvisq*(gradu_nxd+gradv_nyd)
              div = (gradu_nx+gradv_ny)*cvisq
              f1d = gradu_nxd - divd
              f1 = gradu_nx - div
              f2d = gradu_nyd + gradv_nxd
              f2 = gradu_ny + gradv_nx
              f4d = gradv_nyd - divd
              f4 = gradv_ny - div
C
              volinv = 1./(vol(lvor)+vol(lvol))
              xmutvol = (xmut(ir)+xmut(il))*volinv
              xktvol = xmutvol*gam3
C
              fvd = -(xmutvol*(2.*tcx*f1d+tcy*f2d))
              fv = -((2.*f1*tcx+f2*tcy)*xmutvol)
              fv5d = fvd*(rop(ir+v2)+rop(il+v2)) + fv*(ropd(ir+v2)+ropd(
     +          il+v2))
              fv5 = fv*(rop(ir+v2)+rop(il+v2))
              flu2d = flu2d + fvd
              flu2 = flu2 + fv
C
              fvd = -(xmutvol*(tcx*f2d+2.*tcy*f4d))
              fv = -((f2*tcx+2.*f4*tcy)*xmutvol)
              fv5d = fv5d + fvd*(rop(ir+v3)+rop(il+v3)) + fv*(ropd(ir+v3
     +          )+ropd(il+v3))
              fv5 = fv5 + fv*(rop(ir+v3)+rop(il+v3))
              flu3d = flu3d + fvd
              flu3 = flu3 + fv
C
              fvd = 0.5*fv5d - xktvol*(tcx*gradt_nxd+tcy*gradt_nyd)
              fv = fv5*0.5 - (gradt_nx*tcx+gradt_ny*tcy)*xktvol
              flu5d = flu5d + fvd
              flu5 = flu5 + fv
              ls = l - incj
              drodmd(ls+v1) = drodmd(ls+v1) - flu1d
              drodmd(ls+v2) = drodmd(ls+v2) - flu2d
              drodmd(ls+v3) = drodmd(ls+v3) - flu3d
              drodmd(ls+v5) = drodmd(ls+v5) - flu5d
            ENDDO
          END IF
        ENDDO
      END IF
      END
C

