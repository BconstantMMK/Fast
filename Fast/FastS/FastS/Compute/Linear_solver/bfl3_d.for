C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
C
C  Differentiation of bfl3 in forward (tangent) mode:
C   variations   of useful results: drodm
C   with respect to varying inputs: rop drodm
      SUBROUTINE BFL3_D(ndom, ithread, param_int, param_real, 
     +                  ind_dm_zone, ind_sdm, psi, wig, stat_wig, rop, 
     +                  ropd, drodm, drodmd, ti, ti_df, tj, tj_df, tk, 
     +                  tk_df, vol, vol_df, venti, ventj, ventk, xmut)
      IMPLICIT NONE
C
C         If (lnrfront(lf)) Then 
C 
C          call bflnr(ndom,idir,lf, 
C     &               neq,neq_mtr,neq_vent,ndimdx, 
C     &               inc2,inc3,
C     &               ind_CL,
C     &               rop, 
C     &               flu, 
C     &               tijk_df,    !metrique VF ou DF 
C     &               ventijk)
C          Endif
C
C
C
C
      INTEGER*4 ndom, ithread, ind_dm_zone(6), ind_sdm(6), param_int(0:*
     +          )
C
      REAL*8 rop(*), drodm(*), xmut(*), ti(*), tj(*), tk(*), vol(*), 
     +       venti(*), ventj(*), ventk(*), wig(*), stat_wig(*), ti_df(*)
     +       , tj_df(*), tk_df(*), vol_df(*), psi(*), param_real(0:*)
      REAL*8 ropd(*), drodmd(*)
C
C     Var loc
      INTEGER*4 ndf, lf, npass, incijk, nb_bc, iptdata, flag_correct_flu
      INTEGER*4 bc_type, pt_bc, pt_bcs, idir, nbdata, lskip
      INTEGER*4 ind_cl(6), ind_cl119(6)
C pas de debordement coin pour calcul des flu
      REAL*8 mobile_coef
      EXTERNAL INDICE_CL_SDM
      npass = 0
      pt_bcs = param_int(70)
Cwrite(*,*)'bc', nb_bc
      nb_bc = param_int(pt_bcs)
      DO ndf=0,nb_bc-1
        pt_bc = param_int(pt_bcs+1+ndf)
C
Cwrite(*,*)'ndf',bc_type,ndf
Con corrige wall et symetrie pour le moment
        bc_type = param_int(pt_bc+0)
C
C
        IF (.NOT.(bc_type .NE. 3 .AND. bc_type .NE. 3 .AND. bc_type .NE.
     +      4 .AND. bc_type .NE. 6 .AND. bc_type .NE. 7 .AND. bc_type 
     +      .NE. 12)) THEN
C     &     .and.bc_type.ne.13.and.bc_type.ne.17) 
C
          idir = param_int(pt_bc+1)
Ccalcul intersection sous domaine et fenetre CL
          nbdata = param_int(pt_bc+8)
C
C
C
CIN
          CALL INDICE_CL_SDM(idir, npass, lskip, param_int(pt_bc+0), 
     +                       param_int(0+3), param_int(0+4), param_int(
     +                       20), param_int(pt_bc+2), ind_dm_zone, 
     +                       ind_sdm, ind_cl, ind_cl119)
COUT
C
C
C
          IF (lskip .EQ. 0) THEN
Cla fenetre sous-domaine n'intersecte pas la Cond Limite no(lf)
C
            IF (idir .EQ. 1) THEN
              ind_cl(1) = 1
              ind_cl(2) = 1
            ELSE IF (idir .EQ. 2) THEN
              ind_cl(2) = ind_cl(1)
            ELSE IF (idir .EQ. 3) THEN
              ind_cl(3) = 1
              ind_cl(4) = 1
            ELSE IF (idir .EQ. 4) THEN
              ind_cl(4) = ind_cl(3)
            ELSE IF (idir .EQ. 5) THEN
              ind_cl(5) = 1
              ind_cl(6) = 1
            ELSE
              ind_cl(6) = ind_cl(5)
            END IF
C
            IF (param_int(33) .EQ. 5) CALL CORR_FLUROE_SELECT_D(ndom, 
     +                                                          ithread
     +                                                          , idir, 
     +                                                         param_int
     +                                                          , 
     +                                                        param_real
     +                                                          , ind_cl
     +                                                          , rop, 
     +                                                          ropd, 
     +                                                          drodm, 
     +                                                          drodmd, 
     +                                                          wig, 
     +                                                          venti, 
     +                                                          ventj, 
     +                                                          ventk, 
     +                                                          ti, tj, 
     +                                                          tk, vol
     +                                                          , xmut)
C
C
CCondition limite paroi adiabatique ou glissante (parflu0,1,2,...)
            flag_correct_flu = 0
Cc.....Traitement de non reflexion 
            IF (((((bc_type .EQ. 3 .OR. bc_type .EQ. 3) .OR. bc_type 
     +          .EQ. 4) .OR. bc_type .EQ. 6) .OR. bc_type .EQ. 7) .OR. 
     +          bc_type .EQ. 12) THEN
C
              mobile_coef = 1.
              iptdata = param_int(param_int(70)+1+ndf+nb_bc)
              IF (nbdata .NE. 0) mobile_coef = param_real(iptdata)
CMise a jour flag pour calcul correct des efforts
C
              IF (idir .LE. 2) THEN
                incijk = 1
                CALL BFLWALL_D(ndom, idir, mobile_coef, param_int(37), 
     +                         param_int, param_real, incijk, ind_cl, 
     +                         rop, ropd, drodm, drodmd, ti, venti)
              ELSE IF (idir .LE. 4) THEN
                incijk = param_int(0)
                CALL BFLWALL_D(ndom, idir, mobile_coef, param_int(37), 
     +                         param_int, param_real, incijk, ind_cl, 
     +                         rop, ropd, drodm, drodmd, tj, ventj)
              ELSE
                incijk = param_int(0+1)*param_int(0)
                CALL BFLWALL_D(ndom, idir, mobile_coef, param_int(38), 
     +                         param_int, param_real, incijk, ind_cl, 
     +                         rop, ropd, drodm, drodmd, tk, ventk)
              END IF
C
              flag_correct_flu = 1
C
            END IF
          END IF
        END IF
      ENDDO
      END
