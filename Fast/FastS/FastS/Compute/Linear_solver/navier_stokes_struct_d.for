C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) -  1 Mar 2018 15:30
C
c***********************************************************************
c     $Date: 2010-11-04 13:25:50 +0100 (Thu, 04 Nov 2010) $
c     $Revision: 64 $
c     $Author: IvanMary $
c***********************************************************************
      subroutine navier_stokes_struct_d(ndo, nbre_thread_actif, 
     &                   ithread, omp_mode, layer_mode, nbre_socket, 
     &                   socket , mx_synchro, lssiter_verif, nptpsi, 
     &                   nitcfg , nitrun    , first_it     , nb_pulse, 
     &                   flagcelln, mjr_dt, param_int, param_real,
     &                   temps, ijkv_sdm, 
     &                   ind_dm_zone, ind_dm_socket, ind_dm_omp,
     &                   socket_topology, lok, topo_s,
     &                   cfl, x, y, z, celln, rop_ssiter,
     &                   rop_ssiterd, krylov_in,
     &                   xmut, xmutd, 
     &                   ti, tj, tk,vol,ti_df,tj_df,tk_df,vol_df,
     &                   venti, ventj, ventk, wig, stat_wig, rot,
     &                   drodm, drodmd, coe, delta, ro_res)
c***********************************************************************
c_U   USER : GUEGAN   
c
C  Differentiation of navier_stokes_struct in forward (tangent) mode:
C   variations   of useful results: drodm
C   with respect to varying inputs: rop_ssiter
C   RW status of diff variables: drodm:out rop_ssiter:in
c***********************************************************************
      IMPLICIT NONE

#include "FastS/param_solver.h"

      INTEGER_E ndo,  Nbre_thread_actif , mx_synchro, first_it,
     & ithread, ithread_io, Nbre_socket, socket, nitrun, nptpsi, nitcfg,
     & nb_pulse,mjr_dt,
     & lssiter_verif,flagCellN,omp_mode,layer_mode
c
      INTEGER_E  ijkv_sdm(3),ind_dm_zone(6), topo_s(3),
     & ind_dm_omp(6), ind_dm_socket(6), socket_topology(3),
     & param_int(0:*), lok(*)

      REAL_E rop_ssiter(*), xmut(*), 
     & coe(*), ti(*), tj(*), tk(*), vol(*), x(*), y(*), 
     & z(*), venti(*), ventj(*), ventk(*), wig(*), stat_wig(*), 
     & rot(*), celln(*), ti_df(*), tj_df(*), tk_df(*), vol_df(*),
     & rop_ssiterd(*), krylov_in(*), drodm(*), drodmd(*),xmutd(*)

      REAL_E delta(*),ro_res(*)

      REAL_E psi(nptpsi)
      REAL_E temps, norm_kry, cfl(3), param_real(0:*)
      REAL_E drodmstk(20000,param_int(NEQ)), rostk(20000,param_int(NEQ))


C Var loc
#include "../FastC/FastC/HPC_LAYER/LOC_VAR_DECLARATION.for"

      INTEGER_E ind_loop(6),neq_rot,depth,nb_bc


#include "FastS/formule_param.h"
#include "FastS/formule_mtr_param.h"
       
#include "../FastC/FastC/HPC_LAYER/SIZE_MIN.for"
#include "../FastC/FastC/HPC_LAYER/WORK_DISTRIBUTION_BEGIN.for"
        return
#include "../FastC/FastC/HPC_LAYER/LOOP_CACHE_BEGIN.for"
#include "../FastC/FastC/HPC_LAYER/INDICE_RANGE.for"


         if(param_int(IFLOW).eq.3) then

           call vispalart_d(ndo, param_int, param_real, ind_grad,
     &                      xmut, xmutd, rop_ssiter, rop_ssiterd)
         endif


        ! Calcul dt/vol
        if(mjr_dt.eq.1) then
             call cptst3(ndo, nitcfg, nitrun, first_it, lssiter_verif,
     &                   flagCellN, param_int, param_real,
     &                   ind_ssa, ind_grad, ind_coe,
     &                   cfl, xmut,rop_ssiter, cellN, coe,
     &                   ti,tj,tk, vol,venti)
        endif

           !! a modifier pour generaliser
c           call src_term_d(ndo, nitcfg, nb_pulse, param_int, param_real,
c     &                     ind_sdm, ind_rhs, ind_ssa,
c     &                     temps,
c     &                     rop_ssiter, rop_ssiterd, xmut, drodm, drodmd,
c     &                     coe, x,y,z,
c     &                     ti,tj,tk,vol, delta)

c#include "../FastC/FastC/HPC_LAYER/SYNCHRO_WAIT.for"

          ! -----assemblage drodm euler+visqueux
          if(param_int(KFLUDOM).eq.1) then

c                call fluausm_select_d(ndo, nitcfg, ithread, 
c     &                        nptpsi, param_int, param_real,ind_dm_zone,
c     &                        ind_sdm, ijkv_thread, ijkv_sdm, 
c     &                        synchro_send_sock, synchro_send_th, 
c     &                        synchro_receive_sock, synchro_receive_th, 
c     &                        ibloc, jbloc, kbloc, 
c     &                        icache, jcache, kcache, 
c     &                        psi, wig, stat_wig, 
c     &                        rop_ssiter, rop_ssiterd,
c     &                        drodm, drodmd,
c     &                        ti, ti_df, tj, tj_df, tk,tk_df,vol,vol_df,
c     &                        venti, ventj, ventk, xmut, xmutd)



          elseif(param_int(KFLUDOM).eq.5) then

c            call fluroe_select_d(ndo, nitcfg, ithread, 
c     &                        nptpsi, param_int, param_real,ind_dm_zone,
c     &                        ind_sdm, ijkv_thread, ijkv_sdm, 
c     &                        synchro_send_sock, synchro_send_th, 
c     &                        synchro_receive_sock, synchro_receive_th, 
c     &                        ibloc, jbloc, kbloc, 
c     &                        icache, jcache, kcache, 
c     &                        psi, wig, stat_wig, 
c     &                        rop_ssiter, rop_ssiterd,
c     &                        drodm, drodmd,
c     &                        ti, ti_df, tj, tj_df, tk,tk_df,vol,vol_df,
c     &                        venti, ventj, ventk, xmut, xmutd)

          elseif (ithread .eq. 1) then
              write(*, *) 'Unknown flux', param_int(KFLUDOM)
          endif

c#include "../FastC/FastC/HPC_LAYER/SYNCHRO_GO.for"

          !correction flux roe au CL si pas de mvt ALE,....
          nb_bc = param_int( param_int(PT_BC) )
          if(param_int(KFLUDOM).eq.5.and.nb_bc.ne.0) then

c            call bfl3_d(ndo, ithread, param_int, 
c     &                  param_real, ind_dm_zone, ind_sdm, 
c     &                  psi, wig, stat_wig, rop_ssiter,
c     &                  rop_ssiterd, drodm, drodmd,
c     &                  ti, ti_df, tj, tj_df, tk, tk_df, 
c     &                  vol, vol_df, venti, ventj, ventk , xmut, xmutd)

          endif
          if(param_int(ITYPCP).le.1.and.
     &        (param_int(IMPLICITSOLVER).eq.1.and.layer_mode.eq.1)) then
              !Assemble Residu Newton; 3q(n+1)-4Q(n)+q(n-1)) + dt (flu(i+1)-(flu(i)) =0
              if(flagCellN.eq.0) then

c               call core3as2_kry_d(param_int, ind_mjr,drodm,drodmd, coe)
    
              else
                 if (ithread.eq.1)write(*, *) 
     &                'Unknown temporal scheme navier_d',
     &                param_int(IMPLICITSOLVER)
                 continue 
cc               call core3as2_chim_kry(ndo,nitcfg, first_it, 
cc     &                                param_int,param_real,
cc     &                                ind_mjr, cellN,
cc     &                                krylov, norm_kry,
cc     &                                rop_ssiter, rop, rop_m1,drodm,coe)
              endif
          endif



          !modifier plage d'indice comme pour mise a jour rk3 sur
          !vecteur unique: rop = rop + drodm et non rop_1 =rop +drodm
          !call id_vect(param_int,ind_mjr,drodmd, rop_ssiterd,krylov_in)

#include "../FastC/FastC/HPC_LAYER/LOOP_CACHE_END.for"
#include "../FastC/FastC/HPC_LAYER/WORK_DISTRIBUTION_END.for"

      END
