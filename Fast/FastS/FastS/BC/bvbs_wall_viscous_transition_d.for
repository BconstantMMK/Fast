C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.13 (r6666M) - 28 May 2018 09:28
C
C  Differentiation of bvbs_wall_viscous_transition in forward (tangent) mode:
C   variations   of useful results: rop
C   with respect to varying inputs: rop
C   RW status of diff variables: rop:in-out
C
C
C
C
C
C
C
C
C
C
C
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 ao√ªt 2013) $
C     $Revision: 35 $
C     $Author: IvanMary $
C***********************************************************************
      SUBROUTINE BVBS_WALL_VISCOUS_TRANSITION_D(idir, lrhs, neq_mtr,
     &                                         nstep,
     +                                          mobile_coef, param_int, 
     +                                          ind_loop, param_real, x
     +                                          , y, z, ventijk, tijk, 
     +                                          rop, ropd)
      IMPLICIT NONE
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
C
      INTEGER*4 idir, lrhs, neq_mtr, nstep,ind_loop(6), param_int(0:*)
C
      REAL*8 x(param_int(42)), y(param_int(42)), z(param_int(42))
C
      REAL*8 rop(param_int(41), param_int(36))
      REAL*8 ropd(param_int(41), param_int(36))
      REAL*8 ventijk(param_int(44), param_int(40))
      REAL*8 tijk(param_int(43), neq_mtr)
      REAL*8 mobile_coef, param_real(0:*)
C Var local
      INTEGER*4 inc2, inc3, li1, li2, l, iref, jref, kref, lij, lr, lp, 
     +          njf, nkf, ldjr, ic, jc, kc, i, j, k, li3, ldp, kc_vent, 
     +          l0, ldjr0, ldx, lx, ltr, lmtr
C
      REAL*8 ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale, tcx, tcy, tcz, 
     +       ventx, venty, ventz, r, u, v, w, ut, vt, wt, ua, va, wa, 
     +       s_1, qn, rnd, zlong_transi, freq_transi, lambdaz_transi, 
     +       ampli_transi, pi, xlong, zlong, x0, y0, omega, lambda, 
     +       c_pertu
      REAL*8 ud, vd, wd
C
C    adresse point courant pour tableau x ou de la taille d'un domaine 
      INTEGER*4 indcg, i_2, j_2, k_2
C    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER*4 inddm, i_1, j_1, k_1
C    adresse interface pour tableau metric
      INTEGER*4 indmtr, i_3, j_3, k_3
C    adresse interface pour tableau vitesse entrainement
      INTEGER*4 indven, i_4, j_4, k_4
      INTRINSIC ATAN
      INTRINSIC SQRT
      INTRINSIC ABS
      EXTERNAL SHAPE_TAB_MTR
      !EXTERNAL RANDOM_NUMBER
      INTRINSIC RANDOM_NUMBER
      INTRINSIC SIN
      INTRINSIC EXP
      REAL*8 arg1
      REAL*8 result1
C
C
C      write(*,*)'idir=', idir,nijk(4),nijk(5),ndimdx
C      write(*,*)'nijk=', nijk
C      write(*,*)'loop vis=', ind_loop
C
C
      IF (idir .NE. 3) THEN
C$OMP SINGLE
        WRITE(*, *) 'BC Wall transition only valide for Jmin'
        STOP
C$OMP END SINGLE   
      ELSE
        pi = 4*ATAN(1.)
C
        li1 = 1 + (ind_loop(1)+param_int(10+3)-1) + (1+param_int(10+3)-1
     +    )*param_int(10) + (1+param_int(10+4)-1)*param_int(10)*
     +    param_int(10+1)
Cwrite(*,*)'transi',x(li1), x(li2),li1,li2
        li2 = 1 + (ind_loop(2)+1+param_int(10+3)-1) + (1+param_int(10+3)
     +    -1)*param_int(10) + (1+param_int(10+4)-1)*param_int(10)*
     +    param_int(10+1)
C
C
Czlong_transi   = 0.001
        arg1 = (x(li1)-x(li2))**2 + (y(li1)-y(li2))**2
        xlong = SQRT(arg1)
C
        zlong_transi = 0.
        freq_transi = 80000.00
        lambdaz_transi = 1.
        ampli_transi = 0.0005
C
        IF (zlong_transi .EQ. 0.0) THEN
          IF (z(1+(ind_loop(1)+param_int(10+3)-1)+(1+param_int(10+3)-1)*
     +        param_int(10)+(1+param_int(10+4)-1)*param_int(10)*
     +        param_int(10+1)) - z(1+(ind_loop(1)+param_int(10+3)-1)+(1+
     +        param_int(10+3)-1)*param_int(10)+(param_int(20+2)+1+
     +        param_int(10+4)-1)*param_int(10)*param_int(10+1)) .GE. 0.
     +    ) THEN
            zlong = z(1+(ind_loop(1)+param_int(10+3)-1)+(1+param_int(10+
     +        3)-1)*param_int(10)+(1+param_int(10+4)-1)*param_int(10)*
     +        param_int(10+1)) - z(1+(ind_loop(1)+param_int(10+3)-1)+(1+
     +        param_int(10+3)-1)*param_int(10)+(param_int(20+2)+1+
     +        param_int(10+4)-1)*param_int(10)*param_int(10+1))
          ELSE
            zlong = -(z(1+(ind_loop(1)+param_int(10+3)-1)+(1+param_int(
     +        10+3)-1)*param_int(10)+(1+param_int(10+4)-1)*param_int(10)
     +        *param_int(10+1))-z(1+(ind_loop(1)+param_int(10+3)-1)+(1+
     +        param_int(10+3)-1)*param_int(10)+(param_int(20+2)+1+
     +        param_int(10+4)-1)*param_int(10)*param_int(10+1)))
          END IF
        ELSE
          zlong = zlong_transi
        END IF
C
        x0 = x(1+((ind_loop(1)+ind_loop(2))/2+param_int(10+3)-1)+(1+
     +    param_int(10+3)-1)*param_int(10)+(1+param_int(10+4)-1)*
     +    param_int(10)*param_int(10+1))
        y0 = y(1+((ind_loop(1)+ind_loop(2))/2+param_int(10+3)-1)+(1+
     +    param_int(10+3)-1)*param_int(10)+(1+param_int(10+4)-1)*
     +    param_int(10)*param_int(10+1))
C
        omega = 2*pi*freq_transi
Cwrite(*,*)'long transi',xlong,x0,'freq et long onde',omega,lambda
        lambda = 2*pi*lambdaz_transi/zlong
C
CSeule la valeur de k_vent et ck_vent a un sens dans cet appel
        xlong = 1./xlong/xlong
C
C......determine la forme des tableuz metrique en fonction de la nature du domaine
        CALL SHAPE_TAB_MTR(neq_mtr, param_int, idir, ic, jc, kc, kc_vent
     +                     , ci_mtr, cj_mtr, ck_mtr, ck_vent, c_ale)
C
        c_ale = c_ale*2.*mobile_coef
        c_pertu = 1.
        IF (lrhs .EQ. 1) THEN
          c_ale = 0.
          c_pertu = 0.
        END IF
Cidir
C
C
        IF (idir .EQ. 1) THEN
C
          iref = 2*ind_loop(2) + 1
Cparam_int(36)
C
C
          IF (param_int(36) .EQ. 5) THEN
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
C
                DO i=ind_loop(1),ind_loop(2)
C
                  l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +              param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +              param_int(0+1)
                  ldjr = 1 + (iref-i+param_int(0+3)-1) + (j+param_int(0+
     +              3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +              0)*param_int(0+1)
                  ldp = 1 + (ind_loop(2)+1+param_int(0+3)-1) + (j+
     +              param_int(0+3)-1)*param_int(0) + (k+param_int(0+4)-1
     +              )*param_int(0)*param_int(0+1)
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  CALL RANDOM_NUMBER(rnd)
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
C
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                DO i=ind_loop(1),ind_loop(2)
C
                  l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +              param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +              param_int(0+1)
                  ldjr = 1 + (iref-i+param_int(0+3)-1) + (j+param_int(0+
     +              3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +              0)*param_int(0+1)
                  ldp = 1 + (ind_loop(2)+1+param_int(0+3)-1) + (j+
     +              param_int(0+3)-1)*param_int(0) + (k+param_int(0+4)-1
     +              )*param_int(0)*param_int(0+1)
C
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd = 0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        ELSE IF (idir .EQ. 2) THEN
C
C
C
          iref = 2*ind_loop(1) - 1
Cparam_int(36)
C
          IF (param_int(36) .EQ. 5) THEN
C
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                DO i=ind_loop(1),ind_loop(2)
C
                  l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +              param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +              param_int(0+1)
                  ldjr = 1 + (iref-i+param_int(0+3)-1) + (j+param_int(0+
     +              3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +              0)*param_int(0+1)
                  ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15
     +              ) + (j+param_int(15+3)-1)*param_int(15+1) + (k+
     +              param_int(15+4)-1)*param_int(15+2)
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                DO i=ind_loop(1),ind_loop(2)
C
                  l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +              param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +              param_int(0+1)
                  ldjr = 1 + (iref-i+param_int(0+3)-1) + (j+param_int(0+
     +              3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +              0)*param_int(0+1)
                  ldp = 1 + (ind_loop(1)+param_int(15+3)-1)*param_int(15
     +              ) + (j+param_int(15+3)-1)*param_int(15+1) + (k+
     +              param_int(15+4)-1)*param_int(15+2)
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        ELSE IF (idir .EQ. 3) THEN
C
C
C
          jref = 2*ind_loop(4) + 1
Cparam_int(36)
C
          IF (param_int(36) .EQ. 5) THEN
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
C
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(jref-j+
     +            param_int(0+3)-1)*param_int(0)+(k+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1))
                l0 = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(ind_loop(4
     +            )+1+param_int(0+3)-1)*param_int(0)+(k+param_int(0+4)-1
     +            )*param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1)+
     +            (k+param_int(15+4)-1)*param_int(15+2))
                lx = lij - (1+(ind_loop(1)+param_int(10+3)-1)+(ind_loop(
     +            4)+1+param_int(10+3)-1)*param_int(10)+(k+param_int(10+
     +            4)-1)*param_int(10)*param_int(10+1))
                ltr = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(
     +            5)+(ind_loop(4)+1+param_int(5+3)-1)*param_int(5+1)+(k+
     +            param_int(5+4)-1)*param_int(5+2))
C
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldjr0 = l - l0
                  ldp = l - lp
                  ldx = l - lx
                  lmtr = l - ltr
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(jref-j+
     +            param_int(0+3)-1)*param_int(0)+(k+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(ind_loop(4)+1+param_int(15+3)-1)*param_int(15+1)+
     +            (k+param_int(15+4)-1)*param_int(15+2))
C
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        ELSE IF (idir .EQ. 4) THEN
C
C
          jref = 2*ind_loop(3) - 1
Cparam_int(36)
C
          IF (param_int(36) .EQ. 5) THEN
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(jref-j+
     +            param_int(0+3)-1)*param_int(0)+(k+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(ind_loop(3)+param_int(15+3)-1)*param_int(15+1)+(k
     +            +param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
C
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(jref-j+
     +            param_int(0+3)-1)*param_int(0)+(k+param_int(0+4)-1)*
     +            param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(ind_loop(3)+param_int(15+3)-1)*param_int(15+1)+(k
     +            +param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        ELSE IF (idir .EQ. 5) THEN
C
C
C
          kref = 2*ind_loop(6) + 1
Cparam_int(36)
C
          IF (param_int(36) .EQ. 5) THEN
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(j+
     +            param_int(0+3)-1)*param_int(0)+(kref-k+param_int(0+4)-
     +            1)*param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(j+param_int(15+3)-1)*param_int(15+1)+(ind_loop(6)
     +            +1+param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(j+
     +            param_int(0+3)-1)*param_int(0)+(kref-k+param_int(0+4)-
     +            1)*param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(j+param_int(15+3)-1)*param_int(15+1)+(ind_loop(6)
     +            +1+param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        ELSE
C
C
C
          kref = 2*ind_loop(5) - 1
Cparam_int(36)
C
          IF (param_int(36) .EQ. 5) THEN
C
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(j+
     +            param_int(0+3)-1)*param_int(0)+(kref-k+param_int(0+4)-
     +            1)*param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(j+param_int(15+3)-1)*param_int(15+1)+(ind_loop(5)
     +            +param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                ENDDO
              ENDDO
            ENDDO
          ELSE
C
            DO k=ind_loop(5),ind_loop(6)
              DO j=ind_loop(3),ind_loop(4)
                lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(
     +            0+3)-1)*param_int(0) + (k+param_int(0+4)-1)*param_int(
     +            0)*param_int(0+1)
                lr = lij - (1+(ind_loop(1)+param_int(0+3)-1)+(j+
     +            param_int(0+3)-1)*param_int(0)+(kref-k+param_int(0+4)-
     +            1)*param_int(0)*param_int(0+1))
                lp = lij - (1+(ind_loop(1)+param_int(15+3)-1)*param_int(
     +            15)+(j+param_int(15+3)-1)*param_int(15+1)+(ind_loop(5)
     +            +param_int(15+4)-1)*param_int(15+2))
CDEC$ IVDEP
                DO l=lij,lij+ind_loop(2)-ind_loop(1)
C
                  ldjr = l - lr
                  ldp = l - lp
                  ventx = ventijk(ldp, 1)
                  venty = ventijk(ldp, 2)
                  ventz = ventijk(ldp, kc_vent)*ck_vent
C
                  tcx = tijk(lmtr, ic)*ci_mtr
                  tcy = tijk(lmtr, jc)*cj_mtr
Con calcule l'inverse de la surface de la facette
                  tcz = tijk(lmtr, kc)*ck_mtr
C
                  arg1 = tcx*tcx + tcy*tcy + tcz*tcz
                  result1 = SQRT(arg1)
                  s_1 = c_pertu/result1
C
                  !CALL RANDOM_NUMBER(rnd)
                  rnd =0.
Cpertu random
Cpertu sinuoidale temps et z + gaussien (x,y)
                  arg1 = -(10.*xlong*((x(ldx)-x0)*(x(ldx)-x0)+(y(ldx)-y0
     +              )*(y(ldx)-y0)))
                  rnd = (rnd-0.5)*ampli_transi*0.05 + 2.*ampli_transi*
     +              SIN(omega*param_real(22))*SIN(lambda*z(ldx))*EXP(
     +              arg1)
C
                  ud = ropd(ldjr, 2)
                  u = rop(ldjr, 2) - tcx*rnd*s_1
                  vd = ropd(ldjr, 3)
                  v = rop(ldjr, 3) - tcy*rnd*s_1
                  wd = ropd(ldjr, 4)
                  w = rop(ldjr, 4) - rnd*c_pertu
C
                  ropd(l, 1) = ropd(ldjr, 1)
                  ropd(l, 2) = -ud
                  ropd(l, 3) = -vd
                  ropd(l, 4) = -wd
C
                  ropd(l, 5) = ropd(ldjr, 5)
                  ropd(l, 6) = -ropd(ldjr, 6)
                ENDDO
              ENDDO
            ENDDO
          END IF
        END IF
      END IF
      END

