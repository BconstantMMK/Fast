C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.12 (r6213) - 13 Oct 2016 10:54
C
C  Differentiation of fluausm_euler_o3_2d in reverse (adjoint) mode:
C   gradient     of useful results: drodm
C   with respect to varying inputs: rop drodm
C   RW status of diff variables: rop:out drodm:in-out
C***********************************************************************
C     $Date: 2013-08-26 16:00:23 +0200 (lun. 26 ao√ªt 2013) $
C     $Revision: 64 $
Cc     $Author: IvanMary $
Cc***********************************************************************
      SUBROUTINE FLUAUSM_EULER_O3_2D_B(ndom, ithread, param_int, 
     &                                 param_real, ind_dm,
     &                                 ind_loop, 
     &                                 ijkv_bloc, ijkv_cache, 
     &                                 synchro_send_sock, 
     &                                 synchro_send_th, 
     &                                 synchro_receive_sock, 
     &                                 synchro_receive_th,
     &                                 ibloc, jbloc,
     &                                 kbloc, icache, jcache, kcache, 
     &                                 rop, ropb, drodm, drodmb, wig, 
     &                                 venti, ventj, ventk, ti, tj, tk, 
     &                                 vol, xmut)
      IMPLICIT NONE

      REAL souszero
      PARAMETER (souszero=-1e-12)
C
C
C# 1 "./FastS/param_solver.h" 1
C
C
      INTEGER*4 ndom, ithread, nptpsi, icache, jcache, kcache, ibloc, 
     +          jbloc, kbloc, ijkv_bloc(3), ijkv_cache(3), ind_loop(6), 
     +          ind_dm(6), synchro_send_sock(3), synchro_send_th(3), 
     +          synchro_receive_sock(3), synchro_receive_th(3), 
     +          param_int(0:*)
C
      REAL*8 xmut(param_int(41))
      REAL*8 rop(param_int(41)*param_int(36))
      REAL*8 ropb(param_int(41)*param_int(36))
      REAL*8 drodm(param_int(41)*param_int(36))
      REAL*8 drodmb(param_int(41)*param_int(36))
      REAL*8 wig(param_int(41)*3)
      REAL*8 venti(param_int(44)*param_int(40))
      REAL*8 ventj(param_int(44)*param_int(40))
      REAL*8 ventk(param_int(44)*param_int(40))
C
      REAL*8 ti(param_int(43)*param_int(37)), tj(param_int(43)*param_int
     +       (37)), tk(param_int(43)*param_int(38))
      REAL*8 vol(param_int(43))
C
      REAL*8 param_real(0:*)
C
C
CC Var loc
      INTEGER*4 inc, incmax, l, lt, i, j, k, incmax2, nm, nm2, np, l0, 
     +          lt0, inci, incj, inck, ci, cj, lij, ltij, inci_mtr, 
     +          incj_mtr, inck_mtr, icorr, jcorr, ls, v1, v2, v3, v4, v5
     +          , v6, wig_i, wig_j, wig_k, lt200, lt100, lt010, lt210, 
     +          lt020, lt110, lt002, lt012, lt102, lt001, lt021, lt201, 
     +          lt120, lvo, lvo200, lvo020, lvo002, vslp, lvol, lvor, ir
     +          , il, l200, l100, l010, l020, l110, l101, l011, v1mtr, 
     +          v2mtr, v3mtr, l001, l002, l210, l220, l201, l202, l021, 
     +          l022, l120, l102, l012
C
      REAL*8 c1, c2, c3, c4, c5, c6, c4sa, c5sa, c6sa, si, sj, sk, qm, 
     +       qp, tcx, tcy, tcz, tc, r1, h1, rou1, rov1, row1, r2, h2, 
     +       rou2, rov2, row2, gam, gam1, qn1, qn2, u, tdu, p1p2, roref
     +       , uref, tam, tam1, son, c, gam2, qm1, qm2, qm3, qm4, qm5, 
     +       qm6, qp1, qp2, qp3, qp4, qp5, qp6, mut1, mut2, flu1, flu2, 
     +       flu3, flu4, flu5, flu6, p1, p2, qen, sigma_1, ck_vent, div
     +       , f1, f2, f3, f4, f5, f6, fv, fv5, volinv, test
      REAL*8 cmus1, temp01, coesut, tix, tiy, tiz, tix1, tiy1, tiz1, tjx
     +       , tjy, tjz, tjx1, tjy1, tjz1, tkx, tky, tkz, tkx1, tky1, 
     +       tkz1, xmutvol, prandt, gam3, cvisq, rgp, gradu_nx, gradu_ny
     +       , gradu_nz, gradv_nx, gradv_ny, gradv_nz, gradw_nx, 
     +       gradw_ny, gradw_nz, gradt_nx, gradt_ny, gradt_nz, delp, 
     +       delm, delq, slq, slp, roff, tmin_1, du, dv, dw, dp, dqn, 
     +       s_1, nx, ny, nz, qn, r, v, w, h, q, r_1, psiroe
      REAL*8 qmb, qpb, r1b, h1b, rou1b, rov1b, r2b, h2b, rou2b, rov2b, 
     +       qn1b, qn2b, ub, tdub, p1p2b, tamb, tam1b, sonb, cb, qm1b, 
     +       qm2b, qm3b, qm5b, qp1b, qp2b, qp3b, qp5b, flu1b, flu2b, 
     +       flu3b, flu5b, p1b, p2b
C
C!    VARIABLES LOCALES POUR LE CALCUL DE dpPg_dpP **************************

      REAL*8 dpRop1_b_dpRop1_h, dpRop1_b_dpRop2_h,
     & dpRop1_b_dpRop3_h, dpRop1_b_dpRop4_h,
     & dpRop1_b_dpRop5_h

      REAL*8 dpRop2_b_dpRop1_h, dpRop2_b_dpRop2_h,
     & dpRop2_b_dpRop3_h, dpRop2_b_dpRop4_h,
     & dpRop2_b_dpRop5_h

      REAL*8 dpRop3_b_dpRop1_h, dpRop3_b_dpRop2_h,
     & dpRop3_b_dpRop3_h, dpRop3_b_dpRop4_h,
     & dpRop3_b_dpRop5_h

      REAL*8 dpRop4_b_dpRop1_h, dpRop4_b_dpRop2_h,
     & dpRop4_b_dpRop3_h, dpRop4_b_dpRop4_h,
     & dpRop4_b_dpRop_h

      REAL*8 dpRop5_b_dpRop1_h, dpRop5_b_dpRop2_h,
     & dpRop5_b_dpRop3_h, dpRop5_b_dpRop4_h,
     & dpRop5_b_dpRop5_h

      REAL*8 ncx,ncy,ncz,surf_nc

      INTEGER  neq_mtr, ic,jc,kc,kc_vent, idir
      REAL*8 ci_mtr,cj_mtr,ck_mtr,c_ale
C
C!    VARIABLES LOCALES POUR LE CALCUL DE dpP_dpW **************************

       REAL*8 dpRop1_dpW1_l, dpRop1_dpW1_np,
     & dpRop2_dpW1_l, dpRop2_dpW1_np,
     & dpRop2_dpW2_l, dpRop2_dpW2_np,
     & dpRop3_dpW1_l, dpRop3_dpW1_np,
     & dpRop3_dpW3_l, dpRop3_dpW3_np,
     & dpRop4_dpW1_l, dpRop4_dpW1_np,
     & dpRop4_dpW4_l, dpRop4_dpW4_np,
     & dpRop5_dpW1_l, dpRop5_dpW2_l, dpRop5_dpW3_l,
     & dpRop5_dpW4_l, dpRop5_dpW5_l,
     & dpRop5_dpW1_np, dpRop5_dpW2_np, dpRop5_dpW3_np,
     & dpRop5_dpW4_np, dpRop5_dpW5_np

       REAL*8 dpRop1_dpW1_nm, dpRop1_dpW1_nm2,
     & dpRop2_dpW1_nm, dpRop2_dpW1_nm2,
     & dpRop2_dpW2_nm, dpRop2_dpW2_nm2,
     & dpRop3_dpW1_nm, dpRop3_dpW1_nm2,
     & dpRop3_dpW3_nm, dpRop3_dpW3_nm2,
     & dpRop4_dpW1_nm, dpRop4_dpW1_nm2,
     & dpRop4_dpW4_nm, dpRop4_dpW4_nm2,
     & dpRop5_dpW1_nm, dpRop5_dpW2_nm, dpRop5_dpW3_nm,
     & dpRop5_dpW4_nm, dpRop5_dpW5_nm,
     & dpRop5_dpW1_nm2, dpRop5_dpW2_nm2, dpRop5_dpW3_nm2,
     & dpRop5_dpW4_nm2, dpRop5_dpW5_nm2

       REAL*8 Cpm, Cvm, rho_e_cin_np, rho_e_cin_l,
     & W1_l, W2_l, W3_l, W4_l, W5_l,
     & W1_np, W2_np, W3_np, W4_np, W5_np,
     & rho_e_cin_nm2, rho_e_cin_nm,
     & W1_nm, W2_nm, W3_nm, W4_nm, W5_nm,
     & W1_nm2, W2_nm2, W3_nm2, W4_nm2, W5_nm2

c*************************************************************************

CC    adresse point courant pour tableau de la taille d'un domaine 
      INTEGER_E inddm, i_1, j_1, k_1
C
CC    adresse interface pour tableau metric
      INTEGER_E indmtr, i_3, j_3, k_3
      INTRINSIC ABS
      INTRINSIC SQRT
      INTRINSIC MAX
      REAL*8 max1
      REAL*8 max1b
      REAL*8 max2
      REAL*8 max2b
      REAL*8 max3
      REAL*8 max3b
      REAL*8 max4
      REAL*8 max4b
      REAL*8 temp
      REAL*8 tempb
      REAL*8 tempb0
      REAL*8 tempb1
      REAL*8 x1b
      REAL*8 temp0
      REAL*8 tempb2
      REAL*8 tempb3
      REAL*8 tempb4
      REAL*8 x2b
      REAL*8 temp1
      REAL*8 tempb5
      REAL*8 tempb6
      REAL*8 tempb7
      REAL*8 x3b
      REAL*8 temp2
      REAL*8 tempb8
      REAL*8 tempb9
      REAL*8 tempb10
      REAL*8 x4b
      INTEGER branch
      INTEGER ad_from
      INTEGER*4 ad_to
      INTEGER ad_from0
      INTEGER*4 ad_to0
      INTEGER ad_from1
      INTEGER*4 ad_to1
      INTEGER ii1
      REAL*8 x4
      REAL*8 x3
      REAL*8 x2
      REAL*8 x1
C
Climiteur 'minmod'
C
CCC!DIR$ ASSUME_ALIGNED xmut: 16
C
      IF (ind_loop(1) .GT. ind_loop(2)) THEN
        DO ii1=1,param_int(41)*param_int(36)
          ropb(ii1) = 0.0
        ENDDO
      ELSE IF (ind_loop(3) .GT. ind_loop(4)) THEN
        DO ii1=1,param_int(41)*param_int(36)
          ropb(ii1) = 0.0
        ENDDO
      ELSE IF (ind_loop(5) .GT. ind_loop(6)) THEN
        DO ii1=1,param_int(41)*param_int(36)
          ropb(ii1) = 0.0
        ENDDO
      ELSE
C
C
        inci = 1
        incj = param_int(0)
C
Cmetric
C
C-----Variables physiques
C
        gam = param_real(1)
CCv(gama-1)= R (gas parfait)
        rgp = param_real(2)*(gam-1.)
        gam1 = gam/(gam-1.)
C
        roref = param_real(3)
        uref = param_real(5)
C
C!si T< 0.01Tinf, alors limiteur null
C
C modif suite chant metrique et suppression tc dans flux final
        c1 = 0.02*uref
C modif suite chant metrique et suppression tc dans flux final
        c2 = 0.02/(uref*roref)
C    roff MUSCL
        c3 = -2.
C
        c6 = 1./6.
        c4 = 5.*c6
        c5 = 2.*c6
        c6 = -(1.*c6)
C
Cc      c7     = c4/c5
C
C
Ccorrection indice boucle i pour traiter l'interface ind_loop(2)+1 si necessaire
        icorr = 0
        jcorr = 0
        IF (ibloc .EQ. ijkv_bloc(1) .AND. synchro_receive_sock(1) .EQ. 0
     +      .AND. icache .EQ. ijkv_cache(1) .AND. synchro_receive_th(1) 
     +      .EQ. 0) icorr = 1
        IF (jbloc .EQ. ijkv_bloc(2) .AND. synchro_receive_sock(2) .EQ. 0
     +      .AND. jcache .EQ. ijkv_cache(2) .AND. synchro_receive_th(2) 
     +      .EQ. 0) jcorr = 1
C
        v1 = 0
        v2 = param_int(41)
        v3 = 2*param_int(41)
        v4 = 3*param_int(41)
        v5 = 4*param_int(41)
C
        v1mtr = 0
        v2mtr = param_int(43)
C
C
C
C
CCC!DIR$ ASSUME (mod(inck,   4) .eq. 0)
CCC!DIR$ ASSUME (mod(incj,   4) .eq. 0)
CCC!DIR$ ASSUME (mod(param_int(41), 4) .eq. 0)
C
        DO k=ind_loop(5),ind_loop(6)
          DO j=ind_loop(3),ind_loop(4)
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
            ad_from = lij + 1
            CALL PUSHINTEGER4(l)
C
CCC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP


C************************************************************************************
C****************** INITIALISATION DU CALCUL DE ROPB SUIVANT J **********************
C************************************************************************************

            DO l=ad_from,lij+1+ind_loop(2)-ind_loop(1)

              lt = l - ltij

Cc.............Metrique
              CALL PUSHREAL8(tcx)
              tcx = tj(lt+v1mtr)
              CALL PUSHREAL8(tcy)
              tcy = tj(lt+v2mtr)
              sj = SQRT(tcx*tcx + tcy*tcy)

              CALL PUSHINTEGER4(nm)
              nm = l - incj
              CALL PUSHINTEGER4(nm2)
              nm2 = l - 2*incj
              CALL PUSHINTEGER4(np)
              np = l + incj

C Pente (qm) a l'interface droite et  (qp) a l'interface gauche

C qm: right state,  qp: left state
              vslp = v1
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1 = qm
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm2)
              qm2 = qm
              CALL PUSHREAL8(qp2)
              qp2 = qp
C
C qm: right state,  qp: left state
              vslp = v3
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm3)
              qm3 = qm
              CALL PUSHREAL8(qp3)
              qp3 = qp
C
C qm: right state,  qp: left state
              vslp = v5
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm5)
              qm5 = qm
              CALL PUSHREAL8(qp5)
              qp5 = qp
C
C Determination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              CALL PUSHREAL8(r1)
              r1 = qp1
              p1 = r1*qp5*rgp
C
C Determination etat droite: ro, roui, roe+p
              CALL PUSHREAL8(r2)
              r2 = qm1
              p2 = r2*qm5*rgp
C
C Determination vitesse normale interface
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
C
C Modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow
Cc^2
              c = rgp*gam*rop(l+v5)
              son = SQRT(qn1*qn1/c)
              tam = c3*son + sj
              IF (0. .LT. tam) THEN
                max1 = tam
                CALL PUSHCONTROL1B(0)
              ELSE
                max1 = 0.
                CALL PUSHCONTROL1B(1)
              END IF
C fct amortissement: c3*Mach+1
              CALL PUSHREAL8(tam1)
              tam1 = max1*c2
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x1 = u
                CALL PUSHCONTROL1B(0)
              ELSE
                x1 = -u
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x1 .LT. c1*sj) THEN
                CALL PUSHREAL8(tdu)
                tdu = c1*sj
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(tdu)
                tdu = x1
                CALL PUSHCONTROL1B(1)
              END IF


            ENDDO ! FIN DE LA BOUCLE EN I
            CALL PUSHINTEGER4(l - 1)
            CALL PUSHINTEGER4(ad_from)

C************** FIN DE INITIALISATION DU CALCUL DE ROPB SUIVANT J *******************
C************************************************************************************
C
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
            ad_from0 = lij + 1
C
CCC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP
C
C
C************************************************************************************
C****************** INITIALISATION DU CALCUL DE ROPB SUIVANT I **********************
C************************************************************************************
C
            DO l=ad_from0,lij+1+ind_loop(2)-ind_loop(1)
C
              lt = l - ltij
C
Cc.............Metrique
              CALL PUSHREAL8(tcx)
              tcx = ti(lt+v1mtr)
              CALL PUSHREAL8(tcy)
              tcy = ti(lt+v2mtr)
              si = SQRT(tcx*tcx + tcy*tcy)
C
              CALL PUSHINTEGER4(nm)
              nm = l - inci
              CALL PUSHINTEGER4(nm2)
              nm2 = l - 2*inci
              CALL PUSHINTEGER4(np)
              np = l + inci
C
C Pente (qm) a l'interface droite et  (qp) a l'interface gauche
C
C qm: right state,  qp: left state
              vslp = v1
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1 = qm
              qp1 = qp
C
C qm: right state,  qp: left state
              vslp = v2
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm2)
              qm2 = qm
              CALL PUSHREAL8(qp2)
              qp2 = qp

C qm: right state,  qp: left state
              vslp = v3
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm3)
              qm3 = qm
              CALL PUSHREAL8(qp3)
              qp3 = qp

C qm: right state,  qp: left state
              vslp = v5
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm5)
              qm5 = qm
              CALL PUSHREAL8(qp5)
              qp5 = qp

C Determination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              CALL PUSHREAL8(r1)
              r1 = qp1
              p1 = r1*qp5*rgp

C Determination etat droite: ro, roui, roe+p
              CALL PUSHREAL8(r2)
              r2 = qm1
              p2 = r2*qm5*rgp

C Determination vitesse normale interface
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy

C Modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow

              c = rgp*gam*rop(l+v5) !c^2
              son = SQRT(qn1*qn1/c)
              tam = c3*son + si
              IF (0. .LT. tam) THEN
                max2 = tam
                CALL PUSHCONTROL1B(0)
              ELSE
                max2 = 0.
                CALL PUSHCONTROL1B(1)
              END IF

C     fct amortissement: c3*Mach+1
              CALL PUSHREAL8(tam1)
              tam1 = max2*c2
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x2 = u
                CALL PUSHCONTROL1B(0)
              ELSE
                x2 = -u
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x2 .LT. c1*si) THEN
                CALL PUSHREAL8(tdu)
                tdu = c1*si
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(tdu)
                tdu = x2
                CALL PUSHCONTROL1B(1)
              END IF

            ENDDO ! FIN DE LA BOUCLE EN I

            CALL PUSHINTEGER4(l - 1)
            CALL PUSHINTEGER4(ad_from0)

C************** FIN DE INITIALISATION DU CALCUL DE ROPB SUIVANT I *******************
C************************************************************************************


C************************************************************************************
C************ INITIALISATION DU CALCUL DE CORRECTION DE ROPB SUIVANT I **************
C************************************************************************************

            IF (icorr .EQ. 1) THEN
              i = ind_loop(2) + 1
              l = 1 + (i+param_int(0+3)-1) + (j+param_int(0+3)-1)*
     +          param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +          param_int(0+1)
              lt = 1 + (i+param_int(5+3)-1)*param_int(5) + (j+param_int(
     +          5+3)-1)*param_int(5+1) + (k+param_int(5+4)-1)*param_int(
     +          5+2)

Cc.............Metrique
              CALL PUSHREAL8(tcx)
              tcx = ti(lt+v1mtr)
              CALL PUSHREAL8(tcy)
              tcy = ti(lt+v2mtr)
              si = SQRT(tcx*tcx + tcy*tcy)

              CALL PUSHINTEGER4(nm)
              nm = l - inci
              CALL PUSHINTEGER4(nm2)
              nm2 = l - 2*inci
              CALL PUSHINTEGER4(np)
              np = l + inci

C Pente (qm) a l'interface droite et  (qp) a l'interface gauche

C qm: right state,  qp: left state
              vslp = v1
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1 = qm
              qp1 = qp

C qm: right state,  qp: left state
              vslp = v2
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm2)
              qm2 = qm
              CALL PUSHREAL8(qp2)
              qp2 = qp

C qm: right state,  qp: left state
              vslp = v3
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm3)
              qm3 = qm
              CALL PUSHREAL8(qp3)
              qp3 = qp

C qm: right state,  qp: left state
              vslp = v5
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm5)
              qm5 = qm
              CALL PUSHREAL8(qp5)
              qp5 = qp

C Determination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              CALL PUSHREAL8(r1)
              r1 = qp1
              p1 = r1*qp5*rgp

C Determination etat droite: ro, roui, roe+p
              CALL PUSHREAL8(r2)
              r2 = qm1
              p2 = r2*qm5*rgp

C Determination vitesse normale interface
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy

C Modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow

              c = rgp*gam*rop(l+v5) !c^2
              son = SQRT(qn1*qn1/c)
              tam = c3*son + si
              IF (0. .LT. tam) THEN
                max3 = tam
                CALL PUSHCONTROL1B(0)
              ELSE
                max3 = 0.
                CALL PUSHCONTROL1B(1)
              END IF

C      fct amortissement: c3*Mach+1
              CALL PUSHREAL8(tam1)
              tam1 = max3*c2
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x3 = u
                CALL PUSHCONTROL1B(0)
              ELSE
                x3 = -u
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x3 .LT. c1*si) THEN
                CALL PUSHREAL8(tdu)
                tdu = c1*si
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(tdu)
                tdu = x3
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF

C********* FIN DE INITIALISATION DU CALCUL DE CORRECTION DE ROPB SUIVANT I **********
C************************************************************************************


          ENDDO ! FIN DE LA BOUCLE EN J


C************************************************************************************
C************ INITIALISATION DU CALCUL DE CORRECTION DE ROPB SUIVANT J **************
C************************************************************************************

          IF (jcorr .EQ. 1) THEN

            j = ind_loop(4) + 1
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
            ad_from1 = lij + 1
            CALL PUSHINTEGER4(l)

CCC    !DIR$ ASSUME (mod(lij,4) .eq. 0)
CDIR$ IVDEP

            DO l=ad_from1,lij+1+ind_loop(2)-ind_loop(1)

              lt = l - ltij

Cc.............Metrique
              CALL PUSHREAL8(tcx)
              tcx = tj(lt+v1mtr)
              CALL PUSHREAL8(tcy)
              tcy = tj(lt+v2mtr)
              sj = SQRT(tcx*tcx + tcy*tcy)
C
              CALL PUSHINTEGER4(nm)
              nm = l - incj
              CALL PUSHINTEGER4(nm2)
              nm2 = l - 2*incj
              CALL PUSHINTEGER4(np)
              np = l + incj

C Pente (qm) a l'interface droite et  (qp) a l'interface gauche

C qm: right state,  qp: left state
              vslp = v1
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              qm1 = qm
              qp1 = qp

C qm: right state,  qp: left state
              vslp = v2
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm2)
              qm2 = qm
              CALL PUSHREAL8(qp2)
              qp2 = qp

C qm: right state,  qp: left state
              vslp = v3
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm3)
              qm3 = qm
              CALL PUSHREAL8(qp3)
              qp3 = qp

C qm: right state,  qp: left state
              vslp = v5
              qm = c4*rop(l+vslp) + c5*rop(nm+vslp) + c6*rop(np+vslp)
              qp = c4*rop(nm+vslp) + c6*rop(nm2+vslp) + c5*rop(l+vslp)
              CALL PUSHREAL8(qm5)
              qm5 = qm
              CALL PUSHREAL8(qp5)
              qp5 = qp

C Determination etat gauche (rou1) et droit (rou2): ro, roui, roe+p
              CALL PUSHREAL8(r1)
              r1 = qp1
              p1 = r1*qp5*rgp

C Determination etat droite: ro, roui, roe+p
              CALL PUSHREAL8(r2)
              r2 = qm1
              p2 = r2*qm5*rgp

C Determination vitesse normale interface
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
C
C Modification de vitesse normale par ajout
C de stabilisation de type Rhie-Chow

              c = rgp*gam*rop(l+v5) !c^2
              son = SQRT(qn1*qn1/c)
              tam = c3*son + sj
              IF (0. .LT. tam) THEN
                max4 = tam
                CALL PUSHCONTROL1B(0)
              ELSE
                max4 = 0.
                CALL PUSHCONTROL1B(1)
              END IF

C       fct amortissement: c3*Mach+1
              CALL PUSHREAL8(tam1)
              tam1 = max4*c2
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              IF (u .GE. 0.) THEN
                x4 = u
                CALL PUSHCONTROL1B(0)
              ELSE
                x4 = -u
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x4 .LT. c1*sj) THEN
                CALL PUSHREAL8(tdu)
                tdu = c1*sj
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(tdu)
                tdu = x4
                CALL PUSHCONTROL1B(1)
              END IF

            ENDDO ! FIN DE LA BOUCLE EN I

            CALL PUSHINTEGER4(l - 1)
            CALL PUSHINTEGER4(ad_from1)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF

C
C********* FIN DE INITIALISATION DU CALCUL DE CORRECTION DE ROPB SUIVANT J **********
C************************************************************************************
C
        ENDDO ! FIN DE LA BOUCLE EN K
C
C

C####################################################################################
C#####################           CALCULS DE ROPB             ########################
C#####################       ROPB = lambda * dpR/dpP         ########################
C####################################################################################


C********** INITIALISATION DE ROPB
        DO ii1=1,param_int(41)*param_int(36)
          ropb(ii1) = 0.0
        ENDDO


C********** DEBUT DE CALCUL DE ROPB
        DO k=ind_loop(6),ind_loop(5),-1

          CALL POPCONTROL1B(branch)

          IF (branch .NE. 0) THEN

            CALL POPINTEGER4(ad_from1)
            CALL POPINTEGER4(ad_to1)


C************************************************************************************
C************************** CALCUL DE ROPB SUIVANT J ********************************
C************************************************************************************

            DO l=ad_to1,ad_from1,-1
              ls = l - incj
              flu5b = -drodmb(ls+v5)
              flu3b = -drodmb(ls+v3)
              flu2b = -drodmb(ls+v2)
              flu1b = -drodmb(ls+v1)
              p1 = r1*qp5*rgp
              p2 = r2*qm5*rgp
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              rou1 = r1*qp2
              rou2 = r2*qm2
              rov1 = r1*qp3
              rov2 = r2*qm3
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
              ub = (rov1+rov2)*flu3b + (r1+r2)*flu1b + (rou1+rou2)*flu2b
     +          + (h1+h2)*flu5b
              h1b = (tdu+u)*flu5b
              h2b = (u-tdu)*flu5b
              tdub = -((rov2-rov1)*flu3b) - (r2-r1)*flu1b - (rou2-rou1)*
     +          flu2b - (h2-h1)*flu5b
              rov1b = (tdu+u)*flu3b
              rov2b = (u-tdu)*flu3b
              p1p2b = tcx*flu2b + tcy*flu3b
              rou1b = (tdu+u)*flu2b
              rou2b = (u-tdu)*flu2b
              r1b = (tdu+u)*flu1b
              r2b = (u-tdu)*flu1b
              p1b = 0.5*p1p2b
              p2b = 0.5*p1p2b

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                CALL POPREAL8(tdu)
                x4b = 0.0
              ELSE
                CALL POPREAL8(tdu)
                x4b = tdub
              END IF

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                ub = ub + x4b
              ELSE
                ub = ub - x4b
              END IF

              qn1b = 0.25*ub
              qn2b = 0.25*ub
              tam1b = -((p2-p1)*ub)
              p2b = p2b - tam1*ub
              p1b = p1b + tam1*ub
              CALL POPREAL8(tam1)
              max4b = c2*tam1b

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                tamb = max4b
              ELSE
                tamb = 0.0
              END IF

              tempb10 = .5*h1b
              rou1b = rou1b + qp2*tempb10
              rov1b = rov1b + qp3*tempb10
              tempb9 = .5*h2b
              rou2b = rou2b + qm2*tempb9
              rov2b = rov2b + qm3*tempb9
              sonb = c3*tamb
              c = rgp*gam*rop(l+v5)
              temp2 = qn1**2/c

              IF (temp2 .EQ. 0.0) THEN
                tempb8 = 0.0
              ELSE
                tempb8 = sonb/(2.0*SQRT(temp2)*c)
              END IF

              qn1b = qn1b + 2*qn1*tempb8
              cb = -(temp2*tempb8)
              ropb(l+v5) = ropb(l+v5) + rgp*gam*cb
              qm2b = rou2*tempb9 + r2*rou2b + tcx*qn2b
              qm3b = rov2*tempb9 + r2*rov2b + tcy*qn2b
              qp2b = rou1*tempb10 + r1*rou1b + tcx*qn1b
              qp3b = rov1*tempb10 + r1*rov1b + tcy*qn1b
              p2b = p2b + gam1*h2b
              r2b = r2b + qm3*rov2b + qm2*rou2b + rgp*qm5*p2b
              qm5b = rgp*r2*p2b

              CALL POPREAL8(r2)
              qm1b = r2b
              p1b = p1b + gam1*h1b
              r1b = r1b + qp3*rov1b + qp2*rou1b + rgp*qp5*p1b
              qp5b = rgp*r1*p1b
              CALL POPREAL8(r1)
              qp1b = r1b

              CALL POPREAL8(qp5)
              qpb = qp5b
              CALL POPREAL8(qm5)
              qmb = qm5b
              vslp = v5
              nm = l - incj
              nm2 = l - 2*incj
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              np = l + incj
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp3)
              qpb = qp3b
              CALL POPREAL8(qm3)
              qmb = qm3b
              vslp = v3
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp2)
              qpb = qp2b
              CALL POPREAL8(qm2)
              qmb = qm2b
              vslp = v2
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              qpb = qp1b
              qmb = qm1b
              vslp = v1
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPINTEGER4(np)
              CALL POPINTEGER4(nm2)
              CALL POPINTEGER4(nm)
              CALL POPREAL8(tcy)
              CALL POPREAL8(tcx)

            ENDDO ! FIN DE LA BOUCLE EN I

            CALL POPINTEGER4(l)

          END IF

C************************** FIN DE CALCUL DE ROPB SUIVANT J *************************
C************************************************************************************

          DO j=ind_loop(4),ind_loop(3),-1

            CALL POPCONTROL1B(branch)

C************************************************************************************
C**************************** CALCUL DE ROPB SUIVANT I ******************************
C************************************************************************************

            IF (branch .NE. 0) THEN

              ls = l - inci
              flu5b = -drodmb(ls+v5)
              flu3b = -drodmb(ls+v3)
              flu2b = -drodmb(ls+v2)
              flu1b = -drodmb(ls+v1)
              p1 = r1*qp5*rgp
              p2 = r2*qm5*rgp
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              rou1 = r1*qp2
              rou2 = r2*qm2
              rov1 = r1*qp3
              rov2 = r2*qm3
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
              ub = (rov1+rov2)*flu3b + (r1+r2)*flu1b + (rou1+rou2)*flu2b
     +          + (h1+h2)*flu5b
              h1b = (tdu+u)*flu5b
              h2b = (u-tdu)*flu5b
              tdub = -((rov2-rov1)*flu3b) - (r2-r1)*flu1b - (rou2-rou1)*
     +          flu2b - (h2-h1)*flu5b
              rov1b = (tdu+u)*flu3b
              rov2b = (u-tdu)*flu3b
              p1p2b = tcx*flu2b + tcy*flu3b
              rou1b = (tdu+u)*flu2b
              rou2b = (u-tdu)*flu2b
              r1b = (tdu+u)*flu1b
              r2b = (u-tdu)*flu1b
              p1b = 0.5*p1p2b
              p2b = 0.5*p1p2b

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                CALL POPREAL8(tdu)
                x3b = 0.0
              ELSE
                CALL POPREAL8(tdu)
                x3b = tdub
              END IF

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                ub = ub + x3b
              ELSE
                ub = ub - x3b
              END IF

              qn1b = 0.25*ub
              qn2b = 0.25*ub
              tam1b = -((p2-p1)*ub)
              p2b = p2b - tam1*ub
              p1b = p1b + tam1*ub

              CALL POPREAL8(tam1)

              max3b = c2*tam1b
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tamb = max3b
              ELSE
                tamb = 0.0
              END IF

              tempb7 = .5*h1b
              rou1b = rou1b + qp2*tempb7
              rov1b = rov1b + qp3*tempb7
              tempb6 = .5*h2b
              rou2b = rou2b + qm2*tempb6
              rov2b = rov2b + qm3*tempb6
              sonb = c3*tamb
              c = rgp*gam*rop(l+v5)
              temp1 = qn1**2/c

              IF (temp1 .EQ. 0.0) THEN
                tempb5 = 0.0
              ELSE
                tempb5 = sonb/(2.0*SQRT(temp1)*c)
              END IF

              qn1b = qn1b + 2*qn1*tempb5
              cb = -(temp1*tempb5)
              ropb(l+v5) = ropb(l+v5) + rgp*gam*cb
              qm2b = rou2*tempb6 + r2*rou2b + tcx*qn2b
              qm3b = rov2*tempb6 + r2*rov2b + tcy*qn2b
              qp2b = rou1*tempb7 + r1*rou1b + tcx*qn1b
              qp3b = rov1*tempb7 + r1*rov1b + tcy*qn1b
              p2b = p2b + gam1*h2b
              r2b = r2b + qm3*rov2b + qm2*rou2b + rgp*qm5*p2b
              qm5b = rgp*r2*p2b

              CALL POPREAL8(r2)
              qm1b = r2b
              p1b = p1b + gam1*h1b
              r1b = r1b + qp3*rov1b + qp2*rou1b + rgp*qp5*p1b
              qp5b = rgp*r1*p1b
              CALL POPREAL8(r1)
              qp1b = r1b
              CALL POPREAL8(qp5)
              qpb = qp5b
              CALL POPREAL8(qm5)
              qmb = qm5b
              vslp = v5
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp3)
              qpb = qp3b
              CALL POPREAL8(qm3)
              qmb = qm3b
              vslp = v3
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp2)
              qpb = qp2b
              CALL POPREAL8(qm2)
              qmb = qm2b
              vslp = v2
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              qpb = qp1b
              qmb = qm1b
              vslp = v1
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPINTEGER4(np)
              CALL POPINTEGER4(nm2)
              CALL POPINTEGER4(nm)
              CALL POPREAL8(tcy)
              CALL POPREAL8(tcx)

            END IF

            CALL POPINTEGER4(ad_from0)
            CALL POPINTEGER4(ad_to0)

C************************** FIN DE CALCUL DE ROPB SUIVANT I *************************
C************************************************************************************


C************************************************************************************
C************************** MISE A JOUR DE ROPB SUIVANT I ***************************
C************************************************************************************

            DO l=ad_to0,ad_from0,-1

              l0 = l - inci
              flu5b = drodmb(l+v5) - drodmb(l0+v5)
              flu3b = drodmb(l+v3) - drodmb(l0+v3)
              flu2b = drodmb(l+v2) - drodmb(l0+v2)
              flu1b = drodmb(l+v1) - drodmb(l0+v1)
              p1 = r1*qp5*rgp
              p2 = r2*qm5*rgp
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              rou1 = r1*qp2
              rou2 = r2*qm2
              rov1 = r1*qp3
              rov2 = r2*qm3
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
              ub = (rov1+rov2)*flu3b + (r1+r2)*flu1b + (rou1+rou2)*flu2b
     +          + (h1+h2)*flu5b
              h1b = (tdu+u)*flu5b
              h2b = (u-tdu)*flu5b
              tdub = -((rov2-rov1)*flu3b) - (r2-r1)*flu1b - (rou2-rou1)*
     +          flu2b - (h2-h1)*flu5b
              rov1b = (tdu+u)*flu3b
              rov2b = (u-tdu)*flu3b
              p1p2b = tcx*flu2b + tcy*flu3b
              rou1b = (tdu+u)*flu2b
              rou2b = (u-tdu)*flu2b
              r1b = (tdu+u)*flu1b
              r2b = (u-tdu)*flu1b
              p1b = 0.5*p1p2b
              p2b = 0.5*p1p2b

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                CALL POPREAL8(tdu)
                x2b = 0.0
              ELSE
                CALL POPREAL8(tdu)
                x2b = tdub
              END IF

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                ub = ub + x2b
              ELSE
                ub = ub - x2b
              END IF

              qn1b = 0.25*ub
              qn2b = 0.25*ub
              tam1b = -((p2-p1)*ub)
              p2b = p2b - tam1*ub
              p1b = p1b + tam1*ub

              CALL POPREAL8(tam1)
              max2b = c2*tam1b

              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tamb = max2b
              ELSE
                tamb = 0.0
              END IF

              tempb4 = .5*h1b
              rou1b = rou1b + qp2*tempb4
              rov1b = rov1b + qp3*tempb4
              tempb3 = .5*h2b
              rou2b = rou2b + qm2*tempb3
              rov2b = rov2b + qm3*tempb3
              sonb = c3*tamb
              c = rgp*gam*rop(l+v5)
              temp0 = qn1**2/c

              IF (temp0 .EQ. 0.0) THEN
                tempb2 = 0.0
              ELSE
                tempb2 = sonb/(2.0*SQRT(temp0)*c)
              END IF

              qn1b = qn1b + 2*qn1*tempb2
              cb = -(temp0*tempb2)
              ropb(l+v5) = ropb(l+v5) + rgp*gam*cb
              qm2b = rou2*tempb3 + r2*rou2b + tcx*qn2b
              qm3b = rov2*tempb3 + r2*rov2b + tcy*qn2b
              qp2b = rou1*tempb4 + r1*rou1b + tcx*qn1b
              qp3b = rov1*tempb4 + r1*rov1b + tcy*qn1b
              p2b = p2b + gam1*h2b
              r2b = r2b + qm3*rov2b + qm2*rou2b + rgp*qm5*p2b
              qm5b = rgp*r2*p2b

              CALL POPREAL8(r2)
              qm1b = r2b
              p1b = p1b + gam1*h1b
              r1b = r1b + qp3*rov1b + qp2*rou1b + rgp*qp5*p1b
              qp5b = rgp*r1*p1b
              CALL POPREAL8(r1)
              qp1b = r1b

              CALL POPREAL8(qp5)
              qpb = qp5b
              CALL POPREAL8(qm5)
              qmb = qm5b
              vslp = v5
              nm = l - inci
              nm2 = l - 2*inci
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              np = l + inci
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp3)
              qpb = qp3b
              CALL POPREAL8(qm3)
              qmb = qm3b
              vslp = v3
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp2)
              qpb = qp2b
              CALL POPREAL8(qm2)
              qmb = qm2b
              vslp = v2
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              qpb = qp1b
              qmb = qm1b
              vslp = v1
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPINTEGER4(np)
              CALL POPINTEGER4(nm2)
              CALL POPINTEGER4(nm)
              CALL POPREAL8(tcy)
              CALL POPREAL8(tcx)

            ENDDO ! FIN DE LA BOUCLE EN I

            CALL POPINTEGER4(ad_from)
            CALL POPINTEGER4(ad_to)

C********************* FIN DE MISE A JOUR DE ROPB SUIVANT I *************************
C************************************************************************************


C************************************************************************************
C************************** MISE A JOUR DE ROPB SUIVANT J ***************************
C************************************************************************************

            DO l=ad_to,ad_from,-1

              l0 = l - incj
              flu5b = drodmb(l+v5) - drodmb(l0+v5)
              flu3b = drodmb(l+v3) - drodmb(l0+v3)
              flu2b = drodmb(l+v2) - drodmb(l0+v2)
              flu1b = drodmb(l+v1) - drodmb(l0+v1)
              p1 = r1*qp5*rgp
              p2 = r2*qm5*rgp
              qn1 = qp2*tcx + qp3*tcy
              qn2 = qm2*tcx + qm3*tcy
              u = 0.25*(qn1+qn2) - tam1*(p2-p1)
              rou1 = r1*qp2
              rou2 = r2*qm2
              rov1 = r1*qp3
              rov2 = r2*qm3
              h1 = gam1*p1 + .5*(rou1*qp2+rov1*qp3)
              h2 = gam1*p2 + .5*(rou2*qm2+rov2*qm3)
              ub = (rov1+rov2)*flu3b + (r1+r2)*flu1b + (rou1+rou2)*flu2b
     +          + (h1+h2)*flu5b
              h1b = (tdu+u)*flu5b
              h2b = (u-tdu)*flu5b
              tdub = -((rov2-rov1)*flu3b) - (r2-r1)*flu1b - (rou2-rou1)*
     +          flu2b - (h2-h1)*flu5b
              rov1b = (tdu+u)*flu3b
              rov2b = (u-tdu)*flu3b
              p1p2b = tcx*flu2b + tcy*flu3b
              rou1b = (tdu+u)*flu2b
              rou2b = (u-tdu)*flu2b
              r1b = (tdu+u)*flu1b
              r2b = (u-tdu)*flu1b
              p1b = 0.5*p1p2b
              p2b = 0.5*p1p2b

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                CALL POPREAL8(tdu)
                x1b = 0.0
              ELSE
                CALL POPREAL8(tdu)
                x1b = tdub
              END IF

              CALL POPCONTROL1B(branch)

              IF (branch .EQ. 0) THEN
                ub = ub + x1b
              ELSE
                ub = ub - x1b
              END IF

              qn1b = 0.25*ub
              qn2b = 0.25*ub
              tam1b = -((p2-p1)*ub)
              p2b = p2b - tam1*ub
              p1b = p1b + tam1*ub

              CALL POPREAL8(tam1)

              max1b = c2*tam1b
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tamb = max1b
              ELSE
                tamb = 0.0
              END IF

              tempb1 = .5*h1b
              rou1b = rou1b + qp2*tempb1
              rov1b = rov1b + qp3*tempb1
              tempb0 = .5*h2b
              rou2b = rou2b + qm2*tempb0
              rov2b = rov2b + qm3*tempb0
              sonb = c3*tamb
              c = rgp*gam*rop(l+v5)
              temp = qn1**2/c

              IF (temp .EQ. 0.0) THEN
                tempb = 0.0
              ELSE
                tempb = sonb/(2.0*SQRT(temp)*c)
              END IF

              qn1b = qn1b + 2*qn1*tempb
              cb = -(temp*tempb)
              ropb(l+v5) = ropb(l+v5) + rgp*gam*cb
              qm2b = rou2*tempb0 + r2*rou2b + tcx*qn2b
              qm3b = rov2*tempb0 + r2*rov2b + tcy*qn2b
              qp2b = rou1*tempb1 + r1*rou1b + tcx*qn1b
              qp3b = rov1*tempb1 + r1*rov1b + tcy*qn1b
              p2b = p2b + gam1*h2b
              r2b = r2b + qm3*rov2b + qm2*rou2b + rgp*qm5*p2b
              qm5b = rgp*r2*p2b

              CALL POPREAL8(r2)
              qm1b = r2b
              p1b = p1b + gam1*h1b
              r1b = r1b + qp3*rov1b + qp2*rou1b + rgp*qp5*p1b
              qp5b = rgp*r1*p1b
              CALL POPREAL8(r1)
              qp1b = r1b

              CALL POPREAL8(qp5)
              qpb = qp5b
              CALL POPREAL8(qm5)
              qmb = qm5b
              vslp = v5
              nm = l - incj
              nm2 = l - 2*incj
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              np = l + incj
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp3)
              qpb = qp3b
              CALL POPREAL8(qm3)
              qmb = qm3b
              vslp = v3
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPREAL8(qp2)
              qpb = qp2b
              CALL POPREAL8(qm2)
              qmb = qm2b
              vslp = v2
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              qpb = qp1b
              qmb = qm1b
              vslp = v1
              ropb(nm+vslp) = ropb(nm+vslp) + c4*qpb
              ropb(nm2+vslp) = ropb(nm2+vslp) + c6*qpb
              ropb(l+vslp) = ropb(l+vslp) + c4*qmb + c5*qpb
              ropb(nm+vslp) = ropb(nm+vslp) + c5*qmb
              ropb(np+vslp) = ropb(np+vslp) + c6*qmb

              CALL POPINTEGER4(np)
              CALL POPINTEGER4(nm2)
              CALL POPINTEGER4(nm)
              CALL POPREAL8(tcy)
              CALL POPREAL8(tcx)

            ENDDO ! FIN DE LA BOUCLE EN I

            CALL POPINTEGER4(l)


          ENDDO ! FIN DE LA BOUCLE EN J


C********************* FIN DE MISE A JOUR DE ROPB SUIVANT J *************************
C************************************************************************************

        ENDDO ! FIN DE LA BOUCLE EN K


      END IF


C    MISE A JOUR DE ROPB 


      DO k=ind_loop(5),ind_loop(6)
        DO j=ind_loop(3),ind_loop(4)
C
            lij = 1 + (ind_loop(1)+param_int(0+3)-1) + (j+param_int(0+3)
     +        -1)*param_int(0) + (k+param_int(0+4)-1)*param_int(0)*
     +        param_int(0+1) - 1
            ltij = lij - (1+(ind_loop(1)+param_int(5+3)-1)*param_int(5)+
     +        (j+param_int(5+3)-1)*param_int(5+1)+(k+param_int(5+4)-1)*
     +        param_int(5+2)) + 1
            ad_from = lij + 1

          DO l=ad_from,lij+1+ind_loop(2)-ind_loop(1)

              nm = l - inci
              nm2 = l - 2*inci
              np = l + inci


c******************************************************************************
!------------ Calcul des composants de dpRopl_dpRopldjr (dpPg_dpP)
c******************************************************************************

   !      NORMALISATION de tcx, tcy et tcz
       ci_mtr = 1. ! Valeur a integrer depuis BCWallInviscid.for 
       cj_mtr = 1. ! Valeur a integrer depuis BCWallInviscid.for
       ck_mtr = 0. ! Valeur a integrer depuis BCWallInviscid.for

c       idir = param_int_eff(EFF_IDIR)
c       neq_mtr = param_int(NEQ_IJ)

c      call shape_tab_mtr(neq_mtr, param_int, idir,
c     &                   ic,jc,kc,kc_vent,
c     &                   ci_mtr,cj_mtr,ck_mtr,ck_vent,c_ale)

       ncx = tcx*ci_mtr
       ncy = tcy*cj_mtr
       ncz = tcz*ck_mtr

       surf_nc = sqrt(ncx*ncx + ncy*ncy + ncz*ncz)
       surf_nc = max(surf_nc,1e-30)

       ncx = ncx/surf_nc
       ncy = ncy/surf_nc
       ncz = ncz/surf_nc


      if(j.eq.1) then

!      Derivees calculees a partir des fonctions se trouvant dans : .FastS/BC/BCWallInviscid.for
         dpRop1_b_dpRop1_h = 1.

         dpRop2_b_dpRop2_h = 1. - 2.*(ncx**2)
         dpRop2_b_dpRop3_h = - 2.*ncy*ncx
         dpRop2_b_dpRop4_h = - 2.*ncz*ncx

         dpRop3_b_dpRop2_h = - 2.*ncx*ncy
         dpRop3_b_dpRop3_h = 1. - 2.*(ncy**2)
         dpRop3_b_dpRop4_h = - 2.*ncz*ncy

         dpRop4_b_dpRop2_h = - 2.*ncx*ncz
         dpRop4_b_dpRop3_h = - 2.*ncy*ncz
         dpRop4_b_dpRop4_h = 1. - 2.*(ncz**2)

         dpRop5_b_dpRop5_h = 1.


c**********************************************************************************
c!------------ Integration de dpPg_dpP dans ropb : lambda * dpR/dpPg * dpPg/dpP
c**********************************************************************************

C --------- CAS POUR JMIN
       
         ropb(l+v1) = ropb(l+v1) +
     &              ropb(nm+v1) * dpRop1_b_dpRop1_h
         ropb(np+v1) = ropb(np+v1) +
     &               ropb(nm2+v1) * dpRop1_b_dpRop1_h

         ropb(l+v2) = ropb(l+v2) +
     &              ropb(nm+v2) * dpRop2_b_dpRop2_h +
     &              ropb(nm+v3) * dpRop3_b_dpRop2_h
         ropb(np+v2) = ropb(np+v2) +
     &               ropb(nm2+v2) * dpRop2_b_dpRop2_h +
     &               ropb(nm2+v3) * dpRop3_b_dpRop2_h

         ropb(l+v3) = ropb(l+v3) +
     &              ropb(nm+v2) * dpRop2_b_dpRop3_h +
     &              ropb(nm+v3) * dpRop3_b_dpRop3_h
         ropb(np+v3) = ropb(np+v3) +
     &               ropb(nm2+v2) * dpRop2_b_dpRop3_h +
     &               ropb(nm2+v3) * dpRop3_b_dpRop3_h

         ropb(l+v5) = ropb(l+v5) +
     &              ropb(nm+v5) * dpRop5_b_dpRop5_h
         ropb(np+v5) = ropb(np+v5) +
     &               ropb(nm2+v5) * dpRop5_b_dpRop5_h

      end if

C****************************************************************************************
c***********          DEFINITION DE W (VARIABLES CONSERVATIVES)          ****************
C****************************************************************************************

       Cpm = (gam*rgp)/(gam-1) ! Capacit√© calorifique massique √† pression constante
       Cvm = rgp/(gam-1) ! Capacit√© calorifique massique √† volume constant

c------------- En l
       W1_l = rop(l+v1)
       W2_l = rop(l+v1) * rop(l+v2)
       W3_l = rop(l+v1) * rop(l+v3)
       rho_e_cin_l = 0.5*(W2_l**2 + W3_l**2)
       W5_l = Cvm * W1_l * rop(l+v5) + rho_e_cin_l/W1_l

C****************************************************************************************
c***********                      CALCUL de dpP_dpW                      ****************
C****************************************************************************************

c------------- En l
       dpRop1_dpW1_l = 1.

       dpRop2_dpW1_l = -W2_l/(W1_l**2)
       dpRop2_dpW2_l = 1./W1_l

       dpRop3_dpW1_l = -W3_l/(W1_l**2)
       dpRop3_dpW3_l = 1./W1_l

       dpRop5_dpW1_l = 1./Cvm * (- W5_l/(W1_l**2) +
     &                 2 * rho_e_cin_l/(W1_l**3))
       dpRop5_dpW2_l = - 1./Cvm * W2_l/(W1_l**2)
       dpRop5_dpW3_l = - 1./Cvm * W3_l/(W1_l**2)
       dpRop5_dpW5_l = 1./(Cvm * W1_l)

C****************************************************************************************
c***********             CALCUL DE lambda * dpR/dpP * dpP/dpW            ****************
C****************************************************************************************

       ropb(l+v1) = ropb(l+v1) * dprop1_dpW1_l +
     &              ropb(l+v2) * dprop2_dpW1_l +
     &              ropb(l+v3) * dprop3_dpW1_l +
     &              ropb(l+v5) * dprop5_dpW1_l
c       ropb(np+v1) = ropb(np+v1) * dprop1_dpW1_np +
c     &               ropb(np+v2) * dprop2_dpW1_np +
c     &               ropb(np+v3) * dprop3_dpW1_np +
c     &               ropb(np+v5) * dprop5_dpW1_np

       ropb(l+v2) = ropb(l+v2) * dprop2_dpW2_l +
     &              ropb(l+v5) * dprop5_dpW2_l
c       ropb(np+v2) = ropb(np+v2) * dprop2_dpW2_np +
c     &               ropb(np+v5) * dprop5_dpW2_np

       ropb(l+v3) = ropb(l+v3) * dprop3_dpW3_l +
     &              ropb(l+v5) * dprop5_dpW3_l
c       ropb(np+v3) = ropb(np+v3) * dprop2_dpW3_np +
c     &               ropb(np+v5) * dprop5_dpW3_np

       ropb(l+v5) = ropb(l+v5) * dprop5_dpW5_l
c       ropb(np+v5) = ropb(np+v5) * dprop5_dpW5_np

          END DO ! FIN DE LA BOUCLE EN I
        END DO ! FIN DE LA BOUCLE EN J
      END DO ! FIN DE LA BOUCLE EN K

      END ! FIN DE LA SUBROUTINE
